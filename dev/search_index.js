var documenterSearchIndex = {"docs":
[{"location":"packages/LegendTextIO/#LegendTextIO","page":"LegendTextIO","title":"LegendTextIO","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Also see LegendTextIO on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendTextIO/#Modules","page":"LegendTextIO","title":"Modules","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Modules = [LegendTextIO]\nOrder = [:module]","category":"page"},{"location":"packages/LegendTextIO/#Types-and-constants","page":"LegendTextIO","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Modules = [LegendTextIO]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendTextIO/#Functions-and-macros","page":"LegendTextIO","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Modules = [LegendTextIO]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendTextIO/#Documentation","page":"LegendTextIO","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Modules = [LegendTextIO]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendTextIO/#LegendTextIO.DarioHitsFile","page":"LegendTextIO","title":"LegendTextIO.DarioHitsFile","text":"DarioHitsFile(file::Union{IOStream, AbstractString}; batch_size::Integer=10)\n\nrepresents a .root.hits file given by MaGe's Dario output scheme. A DarioHitsFile can be iterated or read to yield events, which contain data on energy depositions, i.e. hits.\n\nA DarioHitsFile is also a Tables.jl compatible row table of events. batch_size determines the number of events grouped into partitions when Tables.partitions is used. To change the default of 10, see DARIO_HITS_BATCH_SIZE.\n\n\n\n\n\n","category":"type"},{"location":"packages/SolidStateDetectors/#SolidStateDetectors","page":"SolidStateDetectors","title":"SolidStateDetectors","text":"","category":"section"},{"location":"packages/SolidStateDetectors/","page":"SolidStateDetectors","title":"SolidStateDetectors","text":"See SolidStateDetectors on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendTestData/#LegendTestData","page":"LegendTestData","title":"LegendTestData","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Also see LegendTestData on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendTestData/#Modules","page":"LegendTestData","title":"Modules","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Modules = [LegendTestData]\nOrder = [:module]","category":"page"},{"location":"packages/LegendTestData/#Types-and-constants","page":"LegendTestData","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Modules = [LegendTestData]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendTestData/#Functions-and-macros","page":"LegendTestData","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Modules = [LegendTestData]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendTestData/#Documentation","page":"LegendTestData","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Modules = [LegendTestData]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendTestData/#LegendTestData.activate_legend_test_data_config-Tuple{}","page":"LegendTestData","title":"LegendTestData.activate_legend_test_data_config","text":"activate_legend_test_data_config()\n\nSet environment variable \"LEGEND_DATA_CONFIG\" to the LEGEND test data configuration\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendTestData/#LegendTestData.legend_test_data_path-Tuple{}","page":"LegendTestData","title":"LegendTestData.legend_test_data_path","text":"legend_test_data_path()::AbstractString\n\nGet local path to the LEGEND test data set.\n\nWill download the test data version matching the current version of LegendTestData if not already present. The local copy of the test data is managed via DataDeps.jl.\n\nSet ENV[\"DATADEPS_ALWAYS_ACCEPT\"] = \"true\" to avoid interactive prompt asking for download permission.\n\n\n\n\n\n","category":"method"},{"location":"packages/BAT/#BAT","page":"BAT","title":"BAT","text":"","category":"section"},{"location":"packages/BAT/","page":"BAT","title":"BAT","text":"See BAT on GitHub and the full package documentation.","category":"page"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Also see RadiationDetectorDSP on GitHub and the full package documentation.","category":"page"},{"location":"packages/RadiationDetectorDSP/#Modules","page":"RadiationDetectorDSP","title":"Modules","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Modules = [RadiationDetectorDSP]\nOrder = [:module]","category":"page"},{"location":"packages/RadiationDetectorDSP/#Types-and-constants","page":"RadiationDetectorDSP","title":"Types and constants","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Modules = [RadiationDetectorDSP]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/RadiationDetectorDSP/#Functions-and-macros","page":"RadiationDetectorDSP","title":"Functions and macros","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Modules = [RadiationDetectorDSP]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/RadiationDetectorDSP/#Documentation","page":"RadiationDetectorDSP","title":"Documentation","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Modules = [RadiationDetectorDSP]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractRadFIRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractRadFIRFilter","text":"abstract type AbstractRadFIRFilter <: AbstractRadLinearFilter\n\nAbstract type for FIR filters.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractRadIIRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractRadIIRFilter","text":"abstract type AbstractRadIIRFilter <: AbstractRadSigFilter{LinearFiltering}\n\nAbstract type for IIR filters.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractRadSigFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractRadSigFilter","text":"abstract type AbstractRadSigFilter{FT<:FilteringType} <: Function\n\nAbstract type for signal filters.\n\nFilters are callable as (flt::AbstractRadSigFilter)(input) and come with specialized broadcasting.\n\nSubtypes of AbstractRadSigFilter must implement\n\nfltinstance(flt::AbstractRadSigFilter, si::SamplingInfo)::[`AbstractRadSigFilterInstance`](@ref)\n\nInvertible filters should also implement\n\nInverseFunctions.inverse(flt::SomeFilter)\n\nNote that while a filter may have an inverse, it may, depending on the filter paramters, be very unstable in the presence of additional noise. Filters with a high-pass characteristic pass high-frequency noise, so their inverses pass such noise as well without amplifying it (substantially). Filters with a low-pass characteristic, on the other hand, attentuate high-frequency noise, so their inverses amplify such noise and are typically not useful to deconvolve signals in practical applications.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractRadSigFilterInstance","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractRadSigFilterInstance","text":"abstract type AbstractRadSigFilterInstance{FT<:FilteringType}\n\nAbstract type for signal filter instances. Filter instances are specilized to a specific length and numerical type of input and output.\n\nFilter instances are callable as (fi::SomeFilterInstance)(input) and come with specialized broadcasting.\n\nSubtypes of AbstractRadSigFilterInstance must implement\n\nRadiationDetectorDSP.rdfilt!(output, fi::SomeFilterInstance, input)\nRadiationDetectorDSP.flt_output_smpltype(fi::SomeFilterInstance)\nRadiationDetectorDSP.flt_input_smpltype(fi::SomeFilterInstance)\nRadiationDetectorDSP.flt_output_length(fi::SomeFilterInstance)\nRadiationDetectorDSP.flt_input_length(fi::SomeFilterInstance)\nRadiationDetectorDSP.flt_output_time_axis(fi::SomeFilterInstance, time::AbstractVector{<:RealQuantity})\n\nInvertible filter instances should implement\n\nInverseFunctions.inverse(fi::SomeFilterInstance)\n\nDefault methods are implemented for\n\nRadiationDetectorDSP.rdfilt(fi::AbstractRadSigFilterInstance, x::AbstractSamples)\nRadiationDetectorDSP.rdfilt(fi::AbstractRadSigFilterInstance, wf::RDWaveform)\nRadiationDetectorDSP.bc_rdfilt(fi::AbstractRadSigFilterInstance, inputs)\n\nThe default methods that operate on RadiationDetectorSignals.RDWaveforms require RadiationDetectorDSP.flt_output_time_axis.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractSamples","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractSamples","text":"const AbstractSamples{T<:RealQuantity} = AbstractVector{T}\n\nA vector of signal samples.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ArrayOfSimilarSamples","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ArrayOfSimilarSamples","text":"const ArrayOfSimilarSamples{T<:RealQuantity} = ArrayOfSimilarVectors{T}\n\nAn array of similar sample vectors.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.BiquadFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.BiquadFilter","text":"struct BiquadFilter{T<:RealQuantity} <: AbstractRadIIRFilter\n\nA biquad filter.\n\nConstructors:\n\nBiquadFilter(fields...)\n\nFields:\n\nb_012::Tuple{T, T, T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Coefficients b0 to b2\na_12::Tuple{T, T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Coefficients a1 to a2, a_0 equals one implicitly\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.CPUNormAdaptor","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.CPUNormAdaptor","text":"RadiationDetectorDSP.CPUNormAdaptor\n\nTo be used with Adapt.adapt.\n\nAdapt.adapt(RadiationDetectorDSP.CPUNormAdaptor, x) adapts x to reside on the CPU and tries to ensure that arrays are stored in column-major order.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.CRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.CRFilter","text":"struct CRFilter <: AbstractRadIIRFilter\n\nA first-order CR highpass filter.\n\nThe inverse filter is InvCRFilter, this is typically stable even in the presence of additional noise. This is because a CR filter passes high-frequency noise and so it's inverse passes such noise as well without amplifying it.\n\nConstructors:\n\nCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.CUSPChargeFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.CUSPChargeFilter","text":"struct CUSPChargeFilter <: AbstractRadFIRFilter\n\nCUSP filter.\n\nFor the definition the filter and a discussion of the filter properties, see\n\nConstructors:\n\nCUSPChargeFilter(; fields...)\n\nFields:\n\nsigma::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: equivalent of shaping time (τₛ) Default: 450\ntoplen::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: length of flat top (FT) Default: 10\ntau::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: decay constant of the exponential Default: 20\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: total length of the filter (L) Default: 100\nbeta::AbstractFloat: scaling factor Default: 100.0\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ConvolutionFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ConvolutionFilter","text":"struct ConvolutionFilter{T<:RealQuantity} <: AbstractRadFIRFilter\n\nA FIR filter defined by it's filter taps, applied via convolution with the input signal.\n\nConstructors:\n\nConvolutionFilter(fields...)\n\nFields:\n\nmethod::RadiationDetectorDSP.ConvolutionMethod: Convolution method\ncoeffs::AbstractVector{T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Filter taps\noffset::Int64: Time axis offset\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ConvolutionMethod","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ConvolutionMethod","text":"abstract type ConvolutionMethod\n\nIndended as a type parameter to designate the behavior of a filter as linear or nonlinear.\n\nSubtypes are DirectConvolution and FFTConvolution.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.DNIMethod","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.DNIMethod","text":"abstract type DNIMethod\n\nAbstract type for denoising and interpolation methods.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.DifferentiatorFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.DifferentiatorFilter","text":"struct DifferentiatorFilter <: AbstractRadIIRFilter\n\nAn integrator filter. It's inverse is IntegratorFilter.\n\nConstructors:\n\nDifferentiatorFilter(fields...)\n\nFields:\n\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Filter gain\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.DirectConvolution","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.DirectConvolution","text":"DirectConvolution() isa ConvolutionMethod\n\nCompute filter convolutions directly, without FFT.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.FFTConvolution","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.FFTConvolution","text":"FFTConvolution() isa ConvolutionMethod\n\nCompute filter convolutions via FFT.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.FilteringType","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.FilteringType","text":"abstract type FilteringType\n\nIndended as a type parameter to designate the behavior of a filter as linear or nonlinear.\n\nSubtypes are LinearFiltering and NonlinearFiltering.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.FirstOrderIIR","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.FirstOrderIIR","text":"struct FirstOrderIIR{T<:RealQuantity} <: AbstractRadIIRFilter\n\nA biquad filter.\n\nConstructors:\n\nFirstOrderIIR(fields...)\n\nFields:\n\nb_01::Tuple{T, T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Coefficients b0 to b1\na_1::Tuple{T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Coefficient a1, a0 equals one implicitly\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.Gauss1DFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.Gauss1DFilter","text":"struct Gauss1DFilter <: AbstractRadFIRFilter\n\nOne dimensional gaussian filter defined as: f(x) = beta * exp(-0.5*(x/sigma)^2) / length\n\nwhere x is in the interval [-alphasigma, alphasigma]\n\nConstructors:\n\nGauss1DFilter(; fields...)\n\nFields:\n\nsigma::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: standard deviation Default: 1.0\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: total length of the filter Default: 100.0\nalpha::AbstractFloat: the amount of standard deviations to cover in the gaussian window Default: 1.0\nbeta::AbstractFloat: scaling factor Default: 100.0\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.IntegratorCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.IntegratorCRFilter","text":"struct IntegratorCRFilter <: AbstractRadIIRFilter\n\nA modified CR-filter. The filter has an inverse.\n\nConstructors:\n\nIntegratorCRFilter(fields...)\n\nFields:\n\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Filter gain\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.IntegratorFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.IntegratorFilter","text":"struct IntegratorFilter <: AbstractRadIIRFilter\n\nAn integrator filter. It's inverse is DifferentiatorFilter.\n\nConstructors:\n\nIntegratorFilter(fields...)\n\nFields:\n\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Filter gain\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.IntegratorModCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.IntegratorModCRFilter","text":"struct IntegratorModCRFilter <: AbstractRadIIRFilter\n\nA modified CR-filter. The filter has an inverse.\n\nConstructors:\n\nIntegratorModCRFilter(fields...)\n\nFields:\n\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Filter gain\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.Intersect","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.Intersect","text":"struct Intersect <: Function\n\nFinds the intersects of a Y with a threshold\n\nConstructors:\n\nIntersect(; fields...)\n\nFields:\n\nmintot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: minimum time-over-threshold\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.InvCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.InvCRFilter","text":"struct InvCRFilter <: AbstractRadIIRFilter\n\nInverse of CRFilter.\n\nConstructors:\n\nInvCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.InvModCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.InvModCRFilter","text":"struct InvModCRFilter <: AbstractRadIIRFilter\n\nInverse of ModCRFilter.\n\nConstructors:\n\nInvModCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.InvRCFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.InvRCFilter","text":"struct InvRCFilter <: AbstractRadIIRFilter\n\nInverse of RCFilter.\n\nConstructors:\n\nInvRCFilter(fields...)\n\nFields:\n\nrc::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: RC time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.InvSecondOrderCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.InvSecondOrderCRFilter","text":"struct InvSecondOrderCRFilter <: AbstractRadIIRFilter\n\nInverse of SecondOrderCRFilter. Apply a double pole-zero cancellation using the provided time constants to the waveform.\n\nConstructors:\n\nInvSecondOrderCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: time constant of the first exponential to be deconvolved\ncr2::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: time constant of the second exponential to be deconvolved\nf::Real: the fraction faktor which the second exponential contributes\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.LinearFiltering","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.LinearFiltering","text":"abstract type LinearFiltering <: FilteringType\n\nWhen used as a type parameter value, marks linear behavior of a filter.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ModCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ModCRFilter","text":"struct ModCRFilter <: AbstractRadIIRFilter\n\nA first-order CR highpass filter, modified for full-amplitude step-signal response.\n\nThe resonse of the standard digital CRFilter will not recover the full amplitude of a digital step stignal since a step from one sample to the still has a finite rise time. This version of a CR filter compensates for this loss in amplitude, so it effectively treats a step as having\n\nThe inverse filter is InvModCRFilter, this is typically stable even in the presence of additional noise (see CRFilter).\n\nConstructors:\n\nModCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.NonlinearFiltering","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.NonlinearFiltering","text":"abstract type NonlinearFiltering <: FilteringType\n\nWhen used as a type parameter value, marks non linear behavior of a filter.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.PolynomialDNI","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.PolynomialDNI","text":"struct PolynomialDNI <: DNIMethod\n\nPolynomial denoising and interpolation method.\n\nOperates in a similar way as a Savitzky-Golay filter, but interpolates as well.\n\nConstructors:\n\nPolynomialDNI(; fields...)\n\nFields:\n\ndegree::Int64: polynomial degree Default: (2, \"length\")\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.RCFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.RCFilter","text":"struct RCFilter <: AbstractRadII>RFilter\n\nA first-order RC lowpass filter.\n\nThe inverse filter is InvCRFilter, but note that this is unstable in the presence of additional noise. As an RC filter attenuates high-frequency noise, its inverse amplifies such noise and will typically not be useful to deconvolve signals in practical applications.\n\nConstructors:\n\nRCFilter(fields...)\n\nFields:\n\nrc::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: RC time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SamplingInfo","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SamplingInfo","text":"struct SamplingInfo{T<:RealQuantity,A<:AbstractVector{<:RealQuantity}}\n\nHolds sampling information.\n\nThe numerical type of an individual sample is T, the (time) axis is given by the axis field.\n\nConstructors:\n\nSamplingInfo{T,A}(axis)\nSamplingInfo{T}(axis)\n\nFields:\n\naxis::AbstractVector{<:Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real}\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SavitzkyGolayFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SavitzkyGolayFilter","text":"struct SavitzkyGolayFilter <: AbstractRadFIRFilter\n\nA Savitzky-Golay filter.\n\nConstructors:\n\nSavitzkyGolayFilter(; fields...)\n\nFields:\n\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: filter length\ndegree::Int64: Polynomial defgree\nderivative::Int64: n-th derivative (0 for no derivative)\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SecondOrderCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SecondOrderCRFilter","text":"struct SecondOrderCRFilter <: AbstractRadIIRFilter\n\nA scond order CR highpass filter. The filter has an inverse InvSecondOrderCRFilter.\n\nConstructors:\n\nSecondOrderCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: time constant of the first exponential to be deconvolved\ncr2::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: time constant of the second exponential to be deconvolved\nf::Real: the fraction faktor which the second exponential contributes\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SignalEstimator","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SignalEstimator","text":"struct SignalEstimator <: Function\n\nEstimates a signal at a given position x.\n\nUsage:\n\n(f::SamplesOrWaveform)(input::RDWaveform, x::RealQuantity)\n\nConstructors:\n\nSignalEstimator(; fields...)\n\nFields:\n\ndni::DNIMethod: denoising and interpolation method\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SimpleCSAFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SimpleCSAFilter","text":"struct SimpleCSAFilter <: AbstractRadIIRFilter\n\nSimulates the current-signal response of a charge-sensitive preamplifier with resistive reset, the output is a charge signal.\n\nIt is equivalent to the composition\n\nCRFilter(cr = tau_decay) ∘\nIntegrator(gain = gain) ∘\nRCFilter(rc = tau_rise)\n\nand maps to a single BiquadFilter.\n\nThis filter has an inverse, but the inverse is very unstable in the presence of additional noise if tau_rise is not zero (since the inverse of an RC-filter is unstable under noise). Even if tau_rise is zero the inverse will still amplify noise (since it differentiates), so it should be used very carefully when deconvolving signals in practical applications.\n\nConstructors:\n\nSimpleCSAFilter(fields...)\n\nFields:\n\ntau_rise::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Rise time constant\ntau_decay::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Decay time constant\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Gain\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.TrapezoidalChargeFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.TrapezoidalChargeFilter","text":"struct TrapezoidalChargeFilter <: AbstractRadNonlinearFilter\n\nFilter that responds to a step signal with a trapezoidal pulse.\n\nThe filter is equivalent to two moving averages separated by a gap.\n\nConstructors:\n\nTrapezoidalChargeFilter(; fields...)\n\nFields:\n\navgtime::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: pre-rise averaging time\ngaptime::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: gap time\navgtime2::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: post-rise averaging time\n\nA sharp step on the input will result in a trapezoid with rise time and fall time avgtime and a flat top of length gaptime.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.TruncateFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.TruncateFilter","text":"struct TruncateFilter <: AbstractRadSigFilter{LinearFiltering}\n\nFilter that truncates the input signal.\n\nConstructors:\n\nTruncateFilter(; fields...)\n\nFields:\n\ninterval::IntervalSets.ClosedInterval{<:Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real}: interval to keep\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ZACChargeFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ZACChargeFilter","text":"struct ZACChargeFilter <: AbstractRadFIRFilter\n\nZero area cusp (ZAC) filter.\n\nFor the definition the filter and a discussion of the filter properties, see \"Improvement of the energy resolution via an optimized digital signal processing in GERDA Phase I\", Eur. Phys. J. C 75, 255 (2015).\n\nConstructors:\n\nZACChargeFilter(; fields...)\n\nFields:\n\nsigma::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: equivalent of shaping time (τₛ) Default: 450\ntoplen::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: length of flat top (FT) Default: 10\ntau::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: decay constant of the exponential Default: 20\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: total length of the filter (L) Default: 100\nbeta::AbstractFloat: scaling factor Default: 100.0\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.MaybeWithUnits","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.MaybeWithUnits","text":"const MaybeWithUnits{T<:Number} = Union{T,Quantity{<:T}}\n\nA numerical value with or without units\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.RealQuantity","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.RealQuantity","text":"const RealQuantity = MaybeWithUnits{<:Real}\n\nA real value with or without units.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SamplesOrWaveform","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SamplesOrWaveform","text":"const RadiationDetectorDSP.SamplesOrWaveform{T<:RealQuantity} = Union{AbstractSamples{T},RDWaveform{<:Any,T}}\n\nA vector of signal samples or a waveform.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.adapt_memlayout","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.adapt_memlayout","text":"RadiationDetectorDSP::adapt_memlayout(\n    fi::AbstractRadSigFilterInstance,\n    backend::KernelAbstractions.Backend,\n    A::AbstractArray{<:Number}\n)\n\nAdapts the memory layout of A in a suitable fashion for fi on computing device backend.\n\nReturns a row-major version of A on all backends by default, filter instance types may specialize this behavior.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.add_rect_pulse!","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.add_rect_pulse!","text":"add_rect_pulse!(samples::AbstractSamples, start::Integer, pulselen::Integer, amplitude::Real = 1.0)\n\nAdd a rectangular pulse to samples.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.bc_rdfilt","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.bc_rdfilt","text":"bc_rdfilt(flt::AbstractRadSigFilter, input)\nbc_rdfilt(fi::AbstractRadSigFilterInstance, input)\n\nBroadcast filter instance fi over signals input, return the filtered signals.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.bc_rdfilt!","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.bc_rdfilt!","text":"bc_rdfilt!(outputs, fi::AbstractRadSigFilterInstance, inputs)\n\nBroadcast filter flt or filter instance fi over signals inputs, storing the results in outputs.\n\ninputs and outputs must be of type AbstractVector{<:AbstractSamples}.\n\nReturns outputs.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.charge_trapflt!-Tuple{AbstractVector{<:Union{var\"#s10\", var\"#s32\"} where {var\"#s10\"<:AbstractFloat, var\"#s32\"<:(SIMD.Vec{N, <:var\"#s10\"} where N)}}, Integer, Integer}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.charge_trapflt!","text":"charge_trapflt!(samples::AbstractVector{<:RealOrSIMD{<:AbstractFloat}}, navg::Integer, ngap::Integer)\n\nApply a trapezoidal FIR filter to a charge signal in samples.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.cr_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.cr_filter","text":"cr_filter(CR::Real)\n\nReturn a DSP.jl-compatible CR-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.crmod_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.crmod_filter","text":"crmod_filter(CR::Real)\n\nReturn a DSP.jl-compatible modified CR-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.cusp_charge_filter_coeffs-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{Int64, U, Int64, V, W}} where {U, V, W<:AbstractFloat}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.cusp_charge_filter_coeffs","text":"cusp_charge_filter_coeffs(N::Int, sigma::U, FT::Int, tau::V, beta::W\n) where {U, V, W <: AbstractFloat}\n\nreturn a vector representing the cusp filter applicaible on a charge  signal, where N is the total length of the filter, FT the length of  the flat top, sigma the filter shaping time,tau the decay constant  and a the scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.dfilt!","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.dfilt!","text":"rdfilt!(output, fi::AbstractRadSigFilterInstance, input)\n\nApply filter flt or filter instance fi to signal input and store the filtered signal in output. Return output.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.differentiator_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.differentiator_filter","text":"differentiator_filter(gain::Real)\n\nReturn a DSP.jl-compatible differentiator filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.elsmplinfo","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.elsmplinfo","text":"smplinfo(smpls::AbstractSamples)::SamplingInfo\nsmplinfo(wf::RDWaveform{T,U})::RDWaveform\n\nGet sampling information an array of vectors of samples, resp. an array of waveform. All elements must have equal samling information.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_input_length","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_input_length","text":"RadiationDetectorDSP.flt_input_length(fi::AbstractRadSigFilterInstance)::Integer\n\nGet the output signal length of a filter instance fi.\n\nMust be implemented for all subtypes of AbstractRadSigFilterInstance.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_input_smpltype","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_input_smpltype","text":"RadiationDetectorDSP.flt_input_smpltype(fi::AbstractRadSigFilterInstance)\n\nGet the input sample type of a filter instance fi.\n\nMust be implemented for all subtypes of AbstractRadSigFilterInstance.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_output_length","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_output_length","text":"RadiationDetectorDSP.flt_output_length(fi::SomeFilterInstance)::Integer\n\nGet the output signal length of filter instance fi.\n\nMust be implemented for all subtypes of AbstractRadSigFilterInstance.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_output_smpltype","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_output_smpltype","text":"RadiationDetectorDSP.flt_output_smpltype(fi::AbstractRadSigFilterInstance)\n\nGet the output sample type for\n\na filter flt given an input sample type input_smpltype\na filter instance fi\n\nMust be implemented for all subtypes of AbstractRadSigFilter.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_output_time_axis","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_output_time_axis","text":"RadiationDetectorDSP.flt_output_time_axis(fi::SomeFilterInstance, time::AbstractVector{<:RealQuantity})::AbstractVector{<:RealQuantity}\n\nGet the output time axis of a filter instance fi, given an input time axis time.\n\nMust be implemented for subtypes of AbstractRadSigFilter and AbstractRadSigFilterInstance only if the filter's output time axis can be computed directly from the input time axis.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.fltinstance","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.fltinstance","text":"fltinstance(flt::AbstractRadSigFilter, si::SamplingInfo)::AbstractRadSigFilterInstance\n\nCreate a filter instance of the filter flt, specialized for the given input, resp. input characteristics.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.gaussian_coeffs-Union{Tuple{U}, Tuple{V}, Tuple{Int64, V, U, U}} where {V, U<:AbstractFloat}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.gaussian_coeffs","text":"gaussian_coeffs(N::Int, sigma::V, alpha::U, beta::U) where {V, U}\n\ncompute a gaussian kernel, where N is the total length of the kernel,  alpha the amount of standard deviations to cover, sigma the standard  deviation and beta the total scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.gen_rect_pulse","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.gen_rect_pulse","text":"gen_rect_pulse(tracelen::Integer, start::Integer, pulselen::Integer, amplitude::Real = 1.0)\n\nGenerate a rectangular pulse.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.integrator_cr_filter-Tuple{Real, Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.integrator_cr_filter","text":"integrator_cr_filter(gain::Real, CR::Real)\n\nReturn a DSP.jl-compatible integrator plus CR filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.integrator_crmod_filter-Tuple{Real, Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.integrator_crmod_filter","text":"integrator_crmod_filter(gain::Real, CR::Real)\n\nReturn a DSP.jl-compatible integrator plus modified CR filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.integrator_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.integrator_filter","text":"integrator_filter(gain::Real)\n\nReturn a DSP.jl-compatible integrator filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.inv_cr_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.inv_cr_filter","text":"inv_cr_filter(CR::Real)\n\nReturn a DSP.jl-compatible inverse CR-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.inv_crmod_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.inv_crmod_filter","text":"inv_crmod_filter(CR::Real)\n\nReturn a DSP.jl-compatible inverse modified CR-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.inv_rc_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.inv_rc_filter","text":"inv_rc_filter(RC::Real)\n\nReturn a DSP.jl-compatible RC-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.multiply_waveform","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.multiply_waveform","text":"multiply_waveform(signal::AbstractSamples, a::RealQuantity)\nmultiply_waveform(wf::RDWaveform, a::RealQuantity)\n\nMultiplies each sample of a waveform by a.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.rc_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.rc_filter","text":"rc_filter(RC::Real)\n\nReturn a DSP.jl-compatible RC-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.rdfilt","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.rdfilt","text":"rdfilt(fi::AbstractRadSigFilterInstance, input)\n\nApply filter instance fi to signal input, return the filtered signal.\n\nReturns output.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.reverse_waveform","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.reverse_waveform","text":"reverse_waveform(signal::AbstractSamples)\nreverse_waveform(wf::RDWaveform)\n\nReverses the order of samples in a waveform.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.shift_waveform","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.shift_waveform","text":"shift_waveform(signal::AbstractSamples, a::RealQuantity)\nshift_waveform(wf::RDWaveform, a::RealQuantity)\n\nShifts each sample of a waveform up by a.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.simple_csa_response_filter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.simple_csa_response_filter","text":"simplecsaresponsefilter(τrise::Real, τdecay::Real, gain::Real = one(τrise))\n\nReturn a DSP.jl-compatible filter that models the response of a typical charge-sensitive amplifier (CSA).\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.smplinfo","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.smplinfo","text":"smplinfo(smpls::AbstractSamples)::SamplingInfo\nsmplinfo(wf::RDWaveform{T,U})::RDWaveform\n\nGet sampling information from a vector of samples, resp. a waveform.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.zac_charge_filter_coeffs-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{Int64, U, Int64, V, W}} where {U, V, W<:AbstractFloat}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.zac_charge_filter_coeffs","text":"zac_charge_filter_coeffs(\n    N::Int, sigma::V, FT::Int, tau::T, beta::U\n    ) where {V, T, U <: AbstractFloat}\n\nreturn a vector representing the zac filter applicaible on a charge  signal, where N is the total length of the filter, FT the length of  the flat top, sigma the filter shaping time, tau the decay constant and beta an additional scaling factor. (see Eur. Phys. J. C (2015) 75:255).\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Also see LegendEventAnalysis on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendEventAnalysis/#Modules","page":"LegendEventAnalysis","title":"Modules","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Modules = [LegendEventAnalysis]\nOrder = [:module]","category":"page"},{"location":"packages/LegendEventAnalysis/#Types-and-constants","page":"LegendEventAnalysis","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Modules = [LegendEventAnalysis]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendEventAnalysis/#Functions-and-macros","page":"LegendEventAnalysis","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Modules = [LegendEventAnalysis]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendEventAnalysis/#Documentation","page":"LegendEventAnalysis","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Modules = [LegendEventAnalysis]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.apply_event_map-Tuple{StructArrays.StructVector, StructArrays.StructVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.apply_event_map","text":"apply_event_map(data::StructVector, evtmap::StructVector)\n\nApply the event map evtmap to the data data.\n\ndata will typically be the result of flatten_over_channels and evtmap the result of build_global_event_map.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.build_cross_system_events-Tuple{NamedTuple}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.build_cross_system_events","text":"function build_cross_system_events(\n    data::NamedTuple,\n    ts_window::Number = 25u\"μs\"\n)\n\nBuild cross-system events.\n\ndata must be a NamedTuple with properties that represent the names of experiment (sub)-systems and values that are the result of build_global_events for each system.\n\nNote: Currently requires the tstart columns of all systems to be identical.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.build_global_event_map-Tuple{StructArrays.StructVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.build_global_event_map","text":"build_global_event_map(local_events::StructArray; ts_window::Number = 25u\"μs\")\n\nBuild a map of global events based on local_events.\n\ndata must contain columns channel, chevtno and timestamp. It will typically be the result of flatten_over_channels.\n\nReturns a StructArray that contains the columns start, channels, localevents and timestamps, sorted by start globally and along timestamps in each row.\n\nThe start column contains the start time of each event, the channels, chevts and timestamps columns are vectors of vectors that contain the channel-id, per-channel event numbers and per-channel timestamps that have been associated with each respective events.\n\nPer-channel events are accociated with the same global event if their timestamps fall within a time windows of length ts_window.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.build_global_events","page":"LegendEventAnalysis","title":"LegendEventAnalysis.build_global_events","text":"function build_global_events(\n    data::AbstractDict{<:ChannelIdLike},\n    channels::AbstractVector{<:ChannelIdLike} = collect(keys(data));\n    ts_window::Number = 25u\"μs\"\n)\n\nBuild global events from a dictionary of per-channel events\n\nPer-channel events are accociated with the same global event if their timestamps fall within a time windows of length ts_window.\n\ndata must a dictionary of in-memory or on-disk table-like objects, keyed by channel-IDs. It may, e.g. be a Dict with values that are StructArrays.StructVector, TypedTables.Table or similar, but may also be a LegendHDF5IO.LHDataStore. Note that on-disk data will be read into memory as a whole.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.calibrate_all","page":"LegendEventAnalysis","title":"LegendEventAnalysis.calibrate_all","text":"calibrate_all(data::LegendData, sel::ValiditySelection, datastore::AbstractDict)\n\nCalibrate all channels in the given datastore, using the metadata processing configuration for data and sel.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.calibrate_aux_channel_data-Tuple{LegendData, AnyValiditySelection, DetectorId, AbstractVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.calibrate_aux_channel_data","text":"calibrate_aux_channel_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, channel_data::AbstractVector)\n\nApply the calibration specified by data and sel for aux channel referred to by the detector ID to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.calibrate_ged_channel_data-Tuple{LegendData, AnyValiditySelection, DetectorId, AbstractVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.calibrate_ged_channel_data","text":"calibrate_ged_channel_data(data::LegendData, sel::AnyValiditySelection, detector::DetectorId, channel_data::AbstractVector; \n    psd_cal_pars_type::Symbol=:ppars, psd_cal_pars_cat::Symbol=:aoe, psd_cut_pars_type::Symbol=:ppars, psd_cut_pars_cat::Symbol=:aoe,\n    keep_chdata::Bool=false)\n\nApply the calibration specified by data and sel for the given HPGe detector to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.calibrate_spm_channel_data-Tuple{LegendData, AnyValiditySelection, DetectorId, AbstractVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.calibrate_spm_channel_data","text":"calibrate_spm_channel_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, channel_data::AbstractVector)\n\nApply the calibration specified by data and sel for the given SiPM detector to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.flag_coincidences-Tuple{AbstractVector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, AbstractVector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.flag_coincidences","text":"flag_coincidences(\n    timestamps::AbstractVector{<:RealQuantity}, ref_timestamps::AbstractVector{<:RealQuantity};\n    ts_window::Number = 125u\"μs\"\n)\n\nFlag coincidences in timestamps with respect to ref_timestamps.\n\nReturn a boolean vector of the same length as timestamps that is true where a timestamp is within ts_window of an element of ref_timestamps and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.flatten_over_channels","page":"LegendEventAnalysis","title":"LegendEventAnalysis.flatten_over_channels","text":"function flatten_over_channels(\n    data::AbstractDict{<:ChannelIdLike},\n    channels::AbstractVector{<:ChannelIdLike} = collect(keys(data))\n)\n\nFlatten per-channel data data to a single StructArrays.StructVector by concatenating its table-like values and adding the columns a channel and chevtno.\n\ndata must a dictionary of in-memory or on-disk table-like objects, keyed by channel-IDs. It may, e.g. be a Dict with values that are StructArrays.StructVector, TypedTables.Table or similar, but may also be a LegendHDF5IO.LHDataStore. Note that on-disk data will be read into memory as a whole.\n\nReturns a NamedTuple{(:result, :per_channel)}: result is the flattened data and per_channel is a channel-indexed dictionary of views into result.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits","page":"LegendSpecFits","title":"LegendSpecFits","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Also see LegendSpecFits on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendSpecFits/#Modules","page":"LegendSpecFits","title":"Modules","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Modules = [LegendSpecFits]\nOrder = [:module]","category":"page"},{"location":"packages/LegendSpecFits/#Types-and-constants","page":"LegendSpecFits","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Modules = [LegendSpecFits]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendSpecFits/#Functions-and-macros","page":"LegendSpecFits","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Modules = [LegendSpecFits]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendSpecFits/#Documentation","page":"LegendSpecFits","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Modules = [LegendSpecFits]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendSpecFits/#LegendSpecFits.LegendSpecFits","page":"LegendSpecFits","title":"LegendSpecFits.LegendSpecFits","text":"LegendSpecFits\n\nTemplate for Julia packages.\n\n\n\n\n\n","category":"module"},{"location":"packages/LegendSpecFits/#LegendSpecFits._get_model_counts-Tuple{Union{Function, Type}, NamedTuple, StepRangeLen, StepRangeLen}","page":"LegendSpecFits","title":"LegendSpecFits._get_model_counts","text":"_get_model_counts(f_fit::Base.Callable,v_ml::NamedTuple,bin_centers::StepRangeLen,bin_widths::StepRangeLen)\n\naux. function to get modelled peakshape based on  histogram binning and best-fit parameter\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits._prepare_data-Tuple{StatsBase.Histogram{<:Real, 1}}","page":"LegendSpecFits","title":"LegendSpecFits._prepare_data","text":"_prepare_data(h::Histogram{<:Real,1})\n\naux. function to convert histogram data into bin edges, bin width and bin counts\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.aoe_compton_background_peakshape-NTuple{5, Real}","page":"LegendSpecFits","title":"LegendSpecFits.aoe_compton_background_peakshape","text":"aoe_compton_background_peakshape(\n    x::Real, μ::Real, σ::Real,\n    background::Real, δ::Real\n)\n\nDescribes the background shape of a typical A/E Compton peak in a detector as a step like background for MSE events.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.aoe_compton_peakshape-NTuple{6, Real}","page":"LegendSpecFits","title":"LegendSpecFits.aoe_compton_peakshape","text":"aoe_compton_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    background::Real, δ::Real\n)\n\nDescribes the shape of a typical A/E Compton peak in a detector as a gaussian SSE peak and a step like background for MSE events.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.aoe_compton_signal_peakshape-NTuple{4, Real}","page":"LegendSpecFits","title":"LegendSpecFits.aoe_compton_signal_peakshape","text":"aoe_compton_signal_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real\n)\n\nDescribes the signal shape of a typical A/E Compton peak in a detector as a gaussian SSE peak.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.array_to_tuple-Tuple{AbstractArray, NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.array_to_tuple","text":"array_to_tuple(a::AbstractArray, as_nt::NamedTuple)\n\nReturn a NamedTuple with the values of a in the order given by fieldnames(as_nt).\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.autocal_energy-Tuple{AbstractArray{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.autocal_energy","text":"autocal_energy(E_raw::AbstractArray{<:Real})\n\nCompute an energy calibration from raw reconstructed energy deposition values.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.background_peakshape-NTuple{5, Real}","page":"LegendSpecFits","title":"LegendSpecFits.background_peakshape","text":"background_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    skew_fraction::Real, skew_width::Real,\n)\n\nDescribes the background part of the shape of a typical gamma peak in a detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.baseline_qc-Union{Tuple{Q}, Tuple{Q, PropDicts.PropDict}} where Q<:TypedTables.Table","page":"LegendSpecFits","title":"LegendSpecFits.baseline_qc","text":"baseline_qc(data, qc_config)\n\nPerform simple Gaussian fits on the baseline disitrbutions for a given data set.\n\nReturns\n\nresult: Namedtuple containing the cut and fit results for each baseline variable\nreport: Namedtuple containing plotable objects.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.chi2fit-Tuple{Function, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.chi2fit","text":"fit_chisq(x::AbstractVector{<:Real},y::AbstractVector{<:Real},yerr::AbstractVector{<:Real}, f_fit::Function;pull_t::Vector{<:NamedTuple} = fill(NamedTuple(), first(methods(f_fit)).nargs - 2), v_init::Vector = [])\n\nLeast square fit with chi2 minimization\n\nInput:\n\nx : x-values\ny : y-values\nyerr : 1 sigma uncertainty on y\nffit : fit/model function. e.g. for a linear function: flin(x,p1,p2)  = p1 .* x .+ p2   \n\nThe numer of fit parameter is determined with first(methods(f_fit)).nargs - 2. That's why it's important that ffit has the synthax f(x,arg1,arg2,arg3,...) pullt : pull term, a vector of NamedTuple with fields mean and std. A Gaussian pull term is added to the chi2 function to account for systematic uncertainties. If left blank, no pull term is used. v_init : initial value for fit parameter optimization. If left blank, the initial value is set to 1 or guessed roughly for all fit parameters\n\nReturn:\n\nresult : NamedTuple with the optimized fit parameter and the fit function\nreport: \n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.ctc_energy","page":"LegendSpecFits","title":"LegendSpecFits.ctc_energy","text":"ctc_energy(e::Array{T}, qdrift::Array{T}, peak::T, window::T) where T<:Real\n\nCorrect for the drift time dependence of the energy by minimizing the ratio of the FWHM and the peak height of the peak around peak in e with a cut window of window. The drift time dependence is given by qdrift.\n\nReturns\n\n* `peak`: peak position\n* `window`: window size\n* `fct`: correction factor\n* `fwhm_before`: FWHM before correction\n* `fwhm_after`: FWHM after correction\n* `func`: function to correct energy\n* `func_generic`: generic function to correct energy\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits.cut_single_peak-Union{Tuple{T}, Tuple{Vector{T}, T, T}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.cut_single_peak","text":"cut_single_peak(x::Array, min_x::Float64, max_x::Float64,; n_bins::Int=15000, relative_cut::Float64=0.5)\n\nCut out a single peak from the array x between min_x and max_x. The number of bins is the number of bins to use for the histogram. The relative cut is the fraction of the maximum counts to use for the cut.\n\nReturns\n\n* `max`: maximum position of the peak\n* `low`: lower edge of the cut peak\n* `high`: upper edge of the cut peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.estimate_combined_peak_stats-Tuple{StructArrays.StructArray}","page":"LegendSpecFits","title":"LegendSpecFits.estimate_combined_peak_stats","text":"estimate_combined_peak_stats(peakstats::StructArray,; calib_type::Symbol=:th228)\n\nEstimate the peak position, FWHM, sigma, counts and background of a peak from a histogram.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.estimate_fwhm-Tuple{NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.estimate_fwhm","text":"estimate_fwhm(v::NamedTuple, v_err::NamedTuple)\n\nGet the FWHM of a peak from the fit parameters.\n\nReturns\n\n* `fwhm`: the FWHM of the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.estimate_single_peak_stats-Tuple{StatsBase.Histogram}","page":"LegendSpecFits","title":"LegendSpecFits.estimate_single_peak_stats","text":"estimate_single_peak_stats(h::Histogram, calib_type::Symbol=:th228)\n\nEstimate statistics/parameters for a single peak in the given histogram h.\n\nh must only contain a single peak. The peak should have a Gaussian-like shape. calib_type specifies the calibration type. Currently only :th228 is implemented. If you want get the peak statistics for a PSD calibration, use :psd.\n\nReturns\n\nNamedTuple with the fields     * peak_pos: estimated position of the peak (in the middle of the peak)     * peak_fwhm: full width at half maximum (FWHM) of the peak     * peak_sigma: estimated standard deviation of the peak     * peak_counts: estimated number of counts in the peak     * mean_background: estimated mean background value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.estimate_single_peak_stats_psd-Union{Tuple{StatsBase.Histogram{T}}, Tuple{T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.estimate_single_peak_stats_psd","text":"estimate_single_peak_stats_psd(h::Histogram{T}) where T<:Real\n\nEstimate peak parameters for a single peak in a histogram using the maximum, the FWHM and the area of the peak.\n\nReturns\n\n* `peak_pos`: Position of the peak\n* `peak_fwhm`: Full width at half maximum of the peak\n* `peak_sigma`: Standard deviation of the peak\n* `peak_counts`: Counts of the peak\n* `mean_background`: Mean background of the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.ex_gauss_pdf-NTuple{4, Real}","page":"LegendSpecFits","title":"LegendSpecFits.ex_gauss_pdf","text":"ex_gauss_pdf(x::Real, μ::Real, σ::Real, θ::Real)\n\nThe PDF of an Exponentially modified Gaussian distribution with Gaussian parameters μ, σ and exponential scale θ at x.\n\nIt is the PDF of the distribution that descibes the random process rand(Normal(μ, σ)) + rand(Exponential(θ)).\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.ex_step_gauss-NTuple{5, Real}","page":"LegendSpecFits","title":"LegendSpecFits.ex_step_gauss","text":"ex_step_gauss(x::Real, l::Real, k::Real, t::Real, d::Real)\n\nEvaluates an extended step gauss model at x with parameters l, k, t and d.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.expand_vars-Tuple{NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.expand_vars","text":"expand_vars(v::NamedTuple)::StructArray\n\nExpand all fields in v (scalars or arrays) to same array size and return a StructArray.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.exponential_decay-NTuple{4, Real}","page":"LegendSpecFits","title":"LegendSpecFits.exponential_decay","text":"exponential_decay(x::Real, amplitude::Real, decay::Real, offset::Real)\n\nEvaluates an exponential decay function at x with parameters amplitude, decay and offset.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.f_optimize_ctc-NTuple{4, Any}","page":"LegendSpecFits","title":"LegendSpecFits.f_optimize_ctc","text":"f_optimize_ctc(fct, e, qdrift, bin_width)\n\nCalculate the ratio of the FWHM and the peak height of the peak around peak in e with a cut window of window. The drift time dependence is given by e_ctc = e + fct * qdrift.\n\nReturns\n\n* `fwhm / p_height`: FWHM of the peak divided by peak height\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_aoe_compton-Union{Tuple{T}, Tuple{Vector{<:StatsBase.Histogram}, StructArrays.StructArray, Array{T}}} where T<:(Union{Unitful.Quantity{var\"#s3\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s3\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s3\"<:Real, U})","page":"LegendSpecFits","title":"LegendSpecFits.fit_aoe_compton","text":"fit_aoe_compton(peakhists::Array, peakstats::StructArray, compton_bands::Array{T}) where T<:Real\n\nFit the A/E Compton bands using the f_aoe_compton function consisting of a gaussian SSE peak and a step like background for MSE events.\n\nReturns\n\n* `result`: Dict of NamedTuples of the fit results containing values and errors for each compton band\n* `report`: Dict of NamedTuples of the fit report which can be plotted for each compton band\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_aoe_corrections-Tuple{Array{<:Union{Unitful.Quantity{var\"#s526\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s526\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s526\"<:Real, U}}, Array{<:Real}, Array{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.fit_aoe_corrections","text":"fitaoecorrections(e::Array{<:Unitful.Energy{<:Real}}, μ::Array{<:Real}, σ::Array{<:Real})\n\nFit the corrections for the AoE value of the detector.\n\nReturns\n\ne: Energy values\nμ: Mean values\nσ: Sigma values\nμ_scs: Fit result for the mean values\nf_μ_scs: Fit function for the mean values\nσ_scs: Fit result for the sigma values\nf_σ_scs: Fit function for the sigma values\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_calibration-Tuple{Int64, AbstractVector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, AbstractVector{<:Unitful.Quantity}}","page":"LegendSpecFits","title":"LegendSpecFits.fit_calibration","text":"fit_calibration(n_poly::Int, µ::AbstractVector{<:Union{Real,Measurement{<:Real}}}, peaks::AbstractVector{<:Union{Real,Measurement{<:Real}}}; pull_t::Vector{<:NamedTuple}=fill(NamedTuple(), n_poly+1), v_init::Vector = [], uncertainty::Bool=true )\n\nFit the calibration lines with polynomial function of npoly order     npoly == 1 -> linear function     n_poly == 2 -> quadratic function\n\nReturns\n\n* `result`: NamedTuple with the following fields\n    * `par`: best-fit parameters\n    * `gof`: godness of fit\n* `report`:\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_enc_sigmas-Union{Tuple{T}, Tuple{Matrix{T}, StepRangeLen{Unitful.Quantity{<:T}, Base.TwicePrecision{Unitful.Quantity{<:T}}, Base.TwicePrecision{Unitful.Quantity{<:T}}, Int64}, T, T, Int64, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_enc_sigmas","text":"fit_enc_sigmas(enc_grid::Matrix{T}, enc_grid_rt::StepRangeLen{Quantity{<:T}, Base.TwicePrecision{Quantity{<:T}}, Base.TwicePrecision{Quantity{<:T}}, Int64}, min_enc::T, max_enc::T, nbins::Int64, rel_cut_fit::T) where T<:Real\n\nFit the ENC values in enc_grid for each RT in enc_grid_rt with a Gaussian and return the optimal RT and the corresponding ENC value.\n\nArguments\n\nenc_grid: 2D array of ENC values for each RT in enc_grid_rt\nenc_grid_rt: 1D array of RT values for which the ENC values in enc_grid are calculated\nmin_enc: minimum ENC value to consider for the fit\nmax_enc: maximum ENC value to consider for the fit\nnbins: number of bins to use for the histogram of ENC values\nrel_cut_fit: relative cut value to use for the fit\n\nReturns\n\nrt: optimal RT value\nmin_enc: corresponding ENC value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_fwhm-Tuple{Vector{<:Union{Unitful.Quantity{var\"#s5\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s5\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s5\"<:Real, U}}, Vector{<:Union{Unitful.Quantity{var\"#s3\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s3\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s3\"<:Real, U}}}","page":"LegendSpecFits","title":"LegendSpecFits.fit_fwhm","text":"fitFWHM(fit_fwhm(peaks::Vector{T}, fwhm::Vector{T}) where T<:Real\n\nFit the FWHM of the peaks to a quadratic function.\n\nReturns\n\n* `qbb`: the FWHM at 2039 keV\n* `err`: the uncertainties of the fit parameters\n* `v`: the fit result parameters\n* `f_fit`: the fitted function\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_fwhm_ft_fep-Union{Tuple{T}, Tuple{Matrix, StepRangeLen{Unitful.Quantity{<:T}, Base.TwicePrecision{Unitful.Quantity{<:T}}, Base.TwicePrecision{Unitful.Quantity{<:T}}, Int64}, Union{Real, Unitful.AbstractQuantity{<:Real}}, T, T, Int64, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_fwhm_ft_fep","text":"fitfwhmftfep(egrid::Matrix, egridft::StepRangeLen{Quantity{<:T}, Base.TwicePrecision{Quantity{<:T}}, Base.TwicePrecision{Quantity{<:T}}, Int64}, rt::Unitful.RealOrRealQuantity, mine::T, maxe::T, nbins::Int64, relcutfit::T; default_ft::Quantity{T}=3.0u\"µs\") where {T <:Real}\n\nFit the FWHM values in e_grid for each FT in e_grid_ft with a Gamma Peakshape and return the optimal FT and the corresponding FWHM value. The cut values cut for each flat-top time a window for better histogramming.\n\nArguments\n\ne_grid: 2D array of energy values for each FT in e_grid_ft\ne_grid_ft: 1D array of FT values for which the FWHM values in e_grid are calculated\nrt: RT value for which the FWHM values in e_grid are calculated\nmin_e: minimum energy value to consider for the fit\nmax_e: maximum energy value to consider for the fit\nnbins: number of bins to use for the histogram of energy values\nrel_cut_fit: relative cut value to use for the fit\n\nReturns\n\nft: optimal FT value\nmin_fwhm: corresponding FWHM value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_half_centered_trunc_gauss-Union{Tuple{T}, Tuple{Vector{T}, T, @NamedTuple{low::T, high::T, max::T}}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.fit_half_centered_trunc_gauss","text":"fit_half_centered_trunc_gauss(x::Array, cuts::NamedTuple{(:low, :high, :max), Tuple{Float64, Float64, Float64}})\n\nFit a single truncated Gaussian to the data x between cut.low and cut.high. The peak center is fixed at μ and the peak is cut in half either in the left or right half.\n\nReturns report and result` with:\n\n* `f_fit`: fitted function\n* `μ`: mean of the Gaussian\n* `μ_err`: error of the mean\n* `σ`: standard deviation of the Gaussian\n* `σ_err`: error of the standard deviation\n* `n`: number of counts in the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_half_trunc_gauss-Union{Tuple{T}, Tuple{Vector{T}, @NamedTuple{low::T, high::T, max::T}}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.fit_half_trunc_gauss","text":"fit_half_centered_trunc_gauss(x::Array, cuts::NamedTuple{(:low, :high, :max), Tuple{Float64, Float64, Float64}})\n\nFit a single truncated Gaussian to the data x between cut.low and cut.high. The peak center is fixed at μ and the peak is cut in half either in the left or right half.\n\nReturns report and result with:\n\n* `f_fit`: fitted function\n* `μ`: mean of the Gaussian\n* `μ_err`: error of the mean\n* `σ`: standard deviation of the Gaussian\n* `σ_err`: error of the standard deviation\n* `n`: number of counts in the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_peaks-Tuple{Array, StructArrays.StructArray, Vector}","page":"LegendSpecFits","title":"LegendSpecFits.fit_peaks","text":"fit_peaks(peakhists::Array, peakstats::StructArray, th228_lines::Array,; calib_type::Symbol=:th228, uncertainty::Bool=true, low_e_tail::Bool=true)\n\nPerform a fit of the peakshape to the data in peakhists using the initial values in peakstats to the calibration lines in th228_lines. \n\nReturns\n\n* `peak_fit_plots`: array of plots of the peak fits\n* `return_vals`: dictionary of the fit results\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_peaks_combined-Tuple{Array, StructArrays.StructArray, Array}","page":"LegendSpecFits","title":"LegendSpecFits.fit_peaks_combined","text":"fit_peaks_combined(peakhists::Array, peakstats::StructArray, th228_lines::Array{T},; calib_type::Symbol=:th228, uncertainty::Bool=true, fixed_position::Bool=false) where T<:Real\n\nFit the peaks of a histogram to a combined peakshape function while sharring parameters between peaks.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_sg_wl-Tuple{NamedTuple{(:dep, :sep)}, StepRangeLen, PropDicts.PropDict}","page":"LegendSpecFits","title":"LegendSpecFits.fit_sg_wl","text":"fit_sg_wl(dep_sep_data, a_grid_wl_sg, optimization_config)\n\nFit the SG window length for the SEP data and return the optimal window length and the corresponding survival fraction.\n\nArguments\n\ndep_sep_data: NamedTuple with the DEP and SEP data\na_grid_wl_sg: range of window lengths to sweep through\noptimization_config: configuration dictionary\n\nReturns\n\nresult: optimal window length and corresponding survival fraction\nreport: report with all window lengths and survival fractions\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_single_aoe_compton-Tuple{StatsBase.Histogram, NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.fit_single_aoe_compton","text":"fit_single_aoe_compton(h::Histogram, ps::NamedTuple{(:peak_pos, :peak_fwhm, :peak_sigma, :peak_counts, :mean_background, :μ, :σ), NTuple{7, T}}; uncertainty::Bool=true) where T<:Real\n\nPerform a fit of the peakshape to the data in h using the initial values in ps while using the f_aoe_compton function consisting of a gaussian SSE peak and a step like background for MSE events.\n\nReturns\n\n* `result`: NamedTuple of the fit results containing values and errors\n* `report`: NamedTuple of the fit report which can be plotted\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_single_peak_th228-Union{Tuple{T}, Tuple{StatsBase.Histogram, @NamedTuple{peak_pos::T, peak_fwhm::T, peak_sigma::T, peak_counts::T, mean_background::T, mean_background_step::T, mean_background_std::T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_single_peak_th228","text":"fit_single_peak_th228(h::Histogram, ps::NamedTuple{(:peak_pos, :peak_fwhm, :peak_sigma, :peak_counts, :mean_background), NTuple{5, T}};, uncertainty::Bool=true, fixed_position::Bool=false, low_e_tail::Bool=true) where T<:Real\n\nPerform a fit of the peakshape to the data in h using the initial values in ps while using the gamma_peakshape with low-E tail. Also, FWHM is calculated from the fitted peakshape with MC error propagation. The peak position can be fixed to the value in ps by setting fixed_position=true. If the low-E tail should not be fitted, it can be disabled by setting low_e_tail=false.\n\nReturns\n\n* `result`: NamedTuple of the fit results containing values and errors\n* `report`: NamedTuple of the fit report which can be plotted\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_single_trunc_gauss-Union{Tuple{T}, Tuple{Vector{T}, @NamedTuple{low::T, high::T, max::T}}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.fit_single_trunc_gauss","text":"fit_single_trunc_gauss(x::Array, cuts::NamedTuple{(:low, :high, :max), Tuple{Float64, Float64, Float64}})\n\nFit a single truncated Gaussian to the data x between min_x and max_x. Returns report and resultwith:     *ffit: fitted function     *μ: mean of the Gaussian     *μerr: error of the mean     *σ: standard deviation of the Gaussian     *σ_err: error of the standard deviation     *n`: number of counts in the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_subpeaks_th228-Tuple{StatsBase.Histogram, StatsBase.Histogram, Any}","page":"LegendSpecFits","title":"LegendSpecFits.fit_subpeaks_th228","text":"fit_single_peak_th228(h::Histogram, ps::NamedTuple{(:peak_pos, :peak_fwhm, :peak_sigma, :peak_counts, :mean_background), NTuple{5, T}};, uncertainty::Bool=true, fixed_position::Bool=false, low_e_tail::Bool=true) where T<:Real\n\nPerform a simultaneous fit of two peaks (h_survived and h_cut) that together would form a histogram h, from which the result h_result was already determined using fit_single_peak_th228. Also, FWHM is calculated from the fitted peakshape with MC error propagation. The peak position can be fixed to the value in ps by setting fixed_position=true. If the low-E tail should not be fitted, it can be disabled by setting low_e_tail=false.\n\nReturns\n\n* `result`: NamedTuple of the fit results containing values and errors, in particular the signal survival fraction `sf` and the background survival frachtion `bsf`.\n* `report`: NamedTuple of the fit report which can be plotted\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.gamma_peakshape-NTuple{8, Real}","page":"LegendSpecFits","title":"LegendSpecFits.gamma_peakshape","text":"gamma_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    step_amplitude::Real, skew_fraction::Real, skew_width::Real,\n    background::Real\n)\n\nDescribes the shape of a typical gamma peak in a detector with a flat background.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.gauss_pdf-Tuple{Real, Real, Real}","page":"LegendSpecFits","title":"LegendSpecFits.gauss_pdf","text":"LegendSpecFits.gauss_pdf(x::Real, μ::Real, σ::Real)\n\nEquivalent to pdf(Normal(μ, σ), x)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.generate_aoe_compton_bands-Union{Tuple{T}, Tuple{Vector{<:Real}, Vector{<:T}, Vector{<:T}, T}} where T<:(Union{Unitful.Quantity{var\"#s124\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s124\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s124\"<:Real, U})","page":"LegendSpecFits","title":"LegendSpecFits.generate_aoe_compton_bands","text":"generate_aoe_compton_bands(aoe::Vector{<:Real}, e::Vector{<:T}, compton_bands::Vector{<:T}, compton_window::T) where T<:Unitful.Energy{<:Real}\n\nGenerate histograms for the A/E Compton bands and estimate peak parameters.  The compton bands are cutted out of the A/E spectrum and then binned using the Freedman-Diaconis Rule. For better performance the binning is only done in the area around the peak. The peak parameters are estimated using the estimate_single_peak_stats_psd function.\n\nReturns\n\n* `peakhists`: Array of histograms for each compton band\n* `peakstats`: StructArray of peak parameters for each compton band\n* `min_aoe`: Array of minimum A/E values for each compton band\n* `max_aoe`: Array of maximum A/E values for each compton band\n* `mean_peak_pos`: Mean peak position of all compton bands\n* `std_peak_pos`: Standard deviation of the peak position of all compton bands\n* `simple_pars_aoe_μ`: Simple curve fit parameters for the peak position energy depencence\n* `simple_pars_error_aoe_μ`: Simple curve fit parameter errors for the peak position energy depencence\n* `simple_pars_aoe_σ`: Simple curve fit parameters for the peak sigma energy depencence\n* `simple_pars_error_aoe_σ`: Simple curve fit parameter errors for the peak sigma energy depencence\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_aoe_cut-Union{Tuple{T}, Tuple{Vector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, Vector{<:T}}} where T<:(Union{Unitful.Quantity{var\"#s145\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s145\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s145\"<:Real, U})","page":"LegendSpecFits","title":"LegendSpecFits.get_aoe_cut","text":"get_aoe_cut(aoe::Vector{<:Unitful.RealOrRealQuantity}, e::Vector{<:T},; dep::T=1592.53u\"keV\", window::Vector{T}=[12.0, 10.0]u\"keV\", dep_sf::Float64=0.9, cut_search_interval::Tuple{Quantity{<:Real}, Quantity{<:Real}}=(-25.0u\"keV^-1\", 0.0u\"keV^-1\"), rtol::Float64=0.001, bin_width_window::T=3.0u\"keV\", fixed_position::Bool=true, sigma_high_sided::Float64=NaN, uncertainty::Bool=true, maxiters::Int=200) where T<:Unitful.Energy{<:Real}\n\nGet the AoE cut value for a given dep and window size while performing a peak fit with fixed position. The AoE cut value is determined by finding the cut value for which the number of counts after the cut is equal to dep_sf times the number of counts before the cut. The algorhithm utilizes a root search algorithm to find the cut value with a relative tolerance of rtol.\n\nReturns\n\ncut: AoE cut value\nn0: Number of counts before the cut\nnsf: Number of counts after the cut\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_centered_gaussian_window_cut-Union{Tuple{T}, Tuple{Vector{T}, T, T, Real}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.get_centered_gaussian_window_cut","text":"get_centered_gaussian_window_cut(x::Array, min_x::Float64, max_x::Float64, n_σ::Real, center::Float64=0.0, n_bins_cut::Int=500, relative_cut::Float64=0.2, left::Bool=false)\n\nCut out a single peak from the array x between min_x and max_x by fitting a truncated one-sided Gaussian and extrapolating a window cut with n_σ standard deviations. The center and side of the fit can be specified with left and center variable.\n\nReturns\n\n* `low_cut`: lower edge of the cut peak\n* `high_cut`: upper edge of the cut peak\n* `center`: center of the peak\n* `σ`: standard deviation of the Gaussian\n* `low_cut_fit`: lower edge of the cut peak from the fit\n* `high_cut_fit`: upper edge of the cut peak from the fit\n* `err`: error of the fit parameters\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_continuum_surrival_fraction-Union{Tuple{T}, Tuple{Vector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, Vector{<:T}, T, T, Union{Real, Unitful.AbstractQuantity{<:Real}}}} where T<:(Union{Unitful.Quantity{var\"#s1251\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s1251\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s1251\"<:Real, U})","page":"LegendSpecFits","title":"LegendSpecFits.get_continuum_surrival_fraction","text":"get_continuum_surrival_fraction(aoe:::Vector{<:Unitful.RealOrRealQuantity}, e::Vector{<:T}, center::T, window::T, aoe_cut::Unitful.RealOrRealQuantity,; sigma_high_sided::Unitful.RealOrRealQuantity=NaN) where T<:Unitful.Energy{<:Real}\n\nGet the surrival fraction of a continuum after a AoE cut value aoe_cut for a given center and window size.\n\nReturns\n\ncenter: Center of the continuum\nwindow: Window size\nn_before: Number of counts before the cut\nn_after: Number of counts after the cut\nsf: Surrival fraction\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_distribution_transform","page":"LegendSpecFits","title":"LegendSpecFits.get_distribution_transform","text":"get_distribution_transform(d::Distribution, pprior::Prior)\n\nReturn a DistributionTransform for the given Distribution and Prior.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_friedman_diaconis_bin_width","page":"LegendSpecFits","title":"LegendSpecFits.get_friedman_diaconis_bin_width","text":"get_friedman_diaconis_bin_width(x::AbstractArray)\n\nReturn the bin width for the given data x using the Friedman-Diaconis rule.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_mc_value_shapes-Tuple{NamedTuple, Matrix, Integer}","page":"LegendSpecFits","title":"LegendSpecFits.get_mc_value_shapes","text":"get_mc_value_shapes(v::NamedTuple, v_err::Matrix, n::Integer)\n\nGenerate n random samples of fit parameters using their respective best-fit values v and covariance matrix v_err\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_mc_value_shapes-Tuple{NamedTuple, NamedTuple, Integer}","page":"LegendSpecFits","title":"LegendSpecFits.get_mc_value_shapes","text":"get_mc_value_shapes(v::NamedTuple, v_err::NamedTuple, n::Integer)\n\nReturn a NamedTuple with the same fields as v and v_err but with Normal distributions for each field.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_n_after_aoe_cut-Union{Tuple{T}, Tuple{Union{Real, Unitful.AbstractQuantity{<:Real}}, Vector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, Vector{<:T}, T, Vector{T}, T, NamedTuple, NamedTuple}} where T<:(Union{Unitful.Quantity{var\"#s1250\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s1250\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s1250\"<:Real, U})","page":"LegendSpecFits","title":"LegendSpecFits.get_n_after_aoe_cut","text":"get_n_after_aoe_cut(aoe_cut::T, aoe::Array{T}, e::Array{T}, peak::T, window::Array{T}, bin_width::T, result_before::NamedTuple, peakstats::NamedTuple; uncertainty=true) where T<:Real\n\nGet the number of counts after a AoE cut value aoe_cut for a given peak and window size while performing a peak fit with fixed position. The number of counts is determined by fitting the peak with a pseudo prior for the peak position.\n\nReturns\n\nn: Number of counts after the cut\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_number_of_bins-Tuple{AbstractArray}","page":"LegendSpecFits","title":"LegendSpecFits.get_number_of_bins","text":"get_number_of_bins(x::AbstractArray,; method::Symbol=:sqrt)\n\nReturn the number of bins for the given data x using the given method.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_peak_fwhm_th228","page":"LegendSpecFits","title":"LegendSpecFits.get_peak_fwhm_th228","text":"get_peak_fwhm_th228(v_ml::NamedTuple, v_ml_err::NamedTuple)\n\nGet the FWHM of a peak from the fit parameters while performing a MC error propagation.\n\nReturns\n\n* `fwhm`: the FWHM of the peak\n* `fwhm_err`: the uncertainty of the FWHM of the peak\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_peak_surrival_fraction-Union{Tuple{T}, Tuple{Vector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, Vector{<:T}, T, Vector{T}, Union{Real, Unitful.AbstractQuantity{<:Real}}}} where T<:(Union{Unitful.Quantity{var\"#s1249\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s1249\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s1249\"<:Real, U})","page":"LegendSpecFits","title":"LegendSpecFits.get_peak_surrival_fraction","text":"get_peak_surrival_fraction(aoe::Array{T}, e::Array{T}, peak::T, window::Array{T}, aoe_cut::T,; uncertainty::Bool=true, low_e_tail::Bool=true) where T<:Real\n\nGet the surrival fraction of a peak after a AoE cut value aoe_cut for a given peak and window size whiile performing a peak fit with fixed position.\n\nReturns\n\npeak: Peak position\nn_before: Number of counts before the cut\nn_after: Number of counts after the cut\nsf: Surrival fraction\nerr: Uncertainties\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_peakhists_th228-Tuple{Vector{<:Union{Unitful.Quantity{var\"#s1257\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s1257\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s1257\"<:Real, U}}, Vector{<:Union{Unitful.Quantity{var\"#s1259\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s1259\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s1259\"<:Real, U}}, Vector{<:Tuple{Union{Unitful.Quantity{var\"#s1261\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s1261\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s1261\"<:Real, U}, Union{Unitful.Quantity{var\"#s1262\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s1262\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s1262\"<:Real, U}}}}","page":"LegendSpecFits","title":"LegendSpecFits.get_peakhists_th228","text":"get_peakhists_th228(e::Array, th228_lines::Array, window_sizes::Array, e_unit::String=\"keV\", proxy_binning_peak::Float64=2103.5, proxy_binning_peak_window::Float64=10.0)\n\nCreate histograms around the calibration lines and return the histograms and the peak statistics.\n\nReturns\n\n* `peakhists`: array of histograms around the calibration lines\n* `peakstats`: array of statistics for the calibration line fits\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_peaks_surrival_fractions-Union{Tuple{T}, Tuple{Vector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, Vector{<:T}, Vector{<:T}, Vector{Symbol}, Vector{<:Tuple{T, T}}, Union{Real, Unitful.AbstractQuantity{<:Real}}}} where T<:(Union{Unitful.Quantity{var\"#s523\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s523\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s523\"<:Real, U})","page":"LegendSpecFits","title":"LegendSpecFits.get_peaks_surrival_fractions","text":"get_peaks_surrival_fractions(aoe::Array{T}, e::Array{T}, peaks::Array{T}, peak_names::Array{Symbol}, windows::Array{T}, aoe_cut::T,; uncertainty=true) where T<:Real\n\nGet the surrival fraction of a peak after a AoE cut value aoe_cut for a given peak and window size while performing a peak fit with fixed position.\n\nReturn\n\nresult: Dict of results for each peak\nreport: Dict of reports for each peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_residuals-Tuple{Union{Function, Type}, StatsBase.Histogram{<:Real, 1}, NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.get_residuals","text":"residuals(f_fit::Base.Callable, h::Histogram{<:Real,1},v_ml::NamedTuple)\n\nCalculate bin-wise residuals and normalized residuals.  Calcualte bin-wise p-value based on poisson distribution for each bin.\n\nInput:\n\nf_fitfunction handle of fit function (peakshape)\nh histogram of data\nv_ml best-fit parameters\n\nReturns:\n\nresiduals difference: model - data (histogram bin count)\nresiduals_norm normalized residuals: model - data / sqrt(model)\np_value_binwise p-value for each bin based on poisson distribution\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_sf_after_aoe_cut-Union{Tuple{T}, Tuple{Union{Real, Unitful.AbstractQuantity{<:Real}}, Vector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, Vector{<:T}, T, Vector{T}, T, NamedTuple}} where T<:(Union{Unitful.Quantity{var\"#s1250\", 𝐋^2 𝐌 𝐓^-2, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s1250\", 𝐋^2 𝐌 𝐓^-2, U}} where {L, S}} where {var\"#s1250\"<:Real, U})","page":"LegendSpecFits","title":"LegendSpecFits.get_sf_after_aoe_cut","text":"get_sf_after_aoe_cut(aoe_cut::T, aoe::Array{T}, e::Array{T}, peak::T, window::Array{T}, bin_width::T, result_before::NamedTuple; uncertainty=true) where T<:Real\n\nGet the survival fraction after a AoE cut value aoe_cut for a given peak and window size from a combined fit to the survived and cut histograms.\n\nReturns\n\nsf: Survival fraction after the cut\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.hist_loglike-Tuple{Union{Function, Type}, StatsBase.Histogram{<:Real, 1}}","page":"LegendSpecFits","title":"LegendSpecFits.hist_loglike","text":"hist_loglike(f_fit::Base.Callable, h::Histogram{<:Real,1})\n\nCalculate the Poisson log-likelihood of a fit function f_fit(x) and a histogram h. f_fit must accept all values x on the horizontal axis of the histogram.\n\nCurrently uses a simple midpoint-rule integration of f_fit over the bins of h.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.linear_function-Tuple{Real, Real, Real}","page":"LegendSpecFits","title":"LegendSpecFits.linear_function","text":"linear_function(x::Real, slope::Real, intercept::Real)\n\nEvaluates a linear function at x with parameters slope and intercept.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.lowEtail_peakshape-NTuple{6, Real}","page":"LegendSpecFits","title":"LegendSpecFits.lowEtail_peakshape","text":"lowEtail_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    skew_fraction::Real, skew_width::Real,\n)\n\nDescribes the low-E signal tail part of the shape of a typical gamma peak in a detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.nearestSPD-Tuple{Matrix{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.nearestSPD","text":"nearestSPD(A::Matrix{<:Real})\n\nReturns the nearest positive definite matrix to A Calculation is based on matrix factorization techniques described in https://www.sciencedirect.com/science/article/pii/0024379588902236\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.p_value-Tuple{Union{Function, Type}, StatsBase.Histogram{<:Real, 1}, NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.p_value","text":"p_value(f_fit::Base.Callable, h::Histogram{<:Real,1},v_ml::NamedTuple)\n\ncalculate p-value based on least-squares, assuming poisson uncertainty baseline method to get goodness-of-fit (gof)\n\ninput:\n\nf_fitfunction handle of fit function (peakshape)\nh histogram of data\nv_ml best-fit parameters\n\nreturns:\n\npval p-value of chi2 test\nchi2 chi2 value\ndof degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.p_value_LogLikeRatio-Tuple{Union{Function, Type}, StatsBase.Histogram{<:Real, 1}, NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.p_value_LogLikeRatio","text":"p_value_LogLikeRatio(f_fit::Base.Callable, h::Histogram{<:Real,1},v_ml::NamedTuple)\n\nAlternative p-value via loglikelihood ratio\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.p_value_MC-Tuple{Union{Function, Type}, StatsBase.Histogram{<:Real, 1}, NamedTuple{(:peak_pos, :peak_fwhm, :peak_sigma, :peak_counts, :mean_background)}, NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.p_value_MC","text":"p_value_MC(f_fit::Base.Callable, h::Histogram{<:Real,1},ps::NamedTuple{(:peak_pos, :peak_fwhm, :peak_sigma, :peak_counts, :mean_background)},v_ml::NamedTuple,;n_samples::Int64=1000)\n\nalternative p-value calculation via Monte Carlo sampling. Warning: computational more expensive than pvaule() and pvalue_LogLikeRatio()\n\nInput:\n\nf_fitfunction handle of fit function (peakshape)\nh histogram of data\nps best-fit parameters\nv_ml best-fit parameters\nn_samples number of samples\n\nPerformed Steps:\n\nCreate n_samples randomized histograms. For each bin, samples are drawn from a Poisson distribution with λ = model peak shape (best-fit parameter)\nEach sample histogram is fit using the model function f_fit\nFor each sample fit, the max. loglikelihood fit is calculated \n\nReturns\n\n% p value –> comparison of sample max. loglikelihood and max. loglikelihood of best-fit\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.prepare_dep_peakhist-Union{Tuple{T}, Tuple{Array{T}, Unitful.Quantity{T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.prepare_dep_peakhist","text":"prepare_dep_peakhist(e::Array{T}, dep::T,; relative_cut::T=0.5, n_bins_cut::Int=500) where T<:Real\n\nPrepare an array of uncalibrated DEP energies for parameter extraction and calibration.\n\nReturns\n\nresult: Result of the initial fit\nreport: Report of the initial fit\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.pulser_cal_qc-Union{Tuple{Q}, Tuple{Q, PropDicts.PropDict}} where Q<:TypedTables.Table","page":"LegendSpecFits","title":"LegendSpecFits.pulser_cal_qc","text":"pulser_cal_qc(data, pulser_config; n_pulser_identified=100)\n\nPerform simple QC cuts on the data and return the data for energy calibration.\n\nReturns\n\n- pulser_idx: indices of the pulser events\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.signal_peakshape-NTuple{5, Real}","page":"LegendSpecFits","title":"LegendSpecFits.signal_peakshape","text":"signal_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    skew_fraction::Real, skew_width::Real,\n)\n\nDescribes the signal part of the shape of a typical gamma peak in a detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.simple_calibration","page":"LegendSpecFits","title":"LegendSpecFits.simple_calibration","text":"simple_calibration(e_uncal::Array, th228_lines::Array, window_size::Float64=25.0, n_bins::Int=15000, calib_type::String=\"th228\")\n\nPerform a simple calibration for the uncalibrated energy array e_uncal  using the calibration type calib_type and the calibration lines th228_lines.  The window size is the size of the window around the calibration line to use for the calibration.  The number of bins is the number of bins to use for the histogram.\n\nReturns      * h_calsimple: histogram of the calibrated energy array     * h_uncal: histogram of the uncalibrated energy array     * c: calibration factor     * fep_guess: estimated full energy peak (FEP)     * peakhists: array of histograms around the calibration lines     * peakstats: array of statistics for the calibration line fits\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits.step_gauss-Tuple{Real, Real, Real}","page":"LegendSpecFits","title":"LegendSpecFits.step_gauss","text":"step_gauss(x::Real, μ::Real, σ::Real)\n\nEvaluates the convulution of a Heaviside step function and the PDF of Normal(μ, σ) at x.\n\nThe result does not correspond to a PDF as it is not normalizable.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.subhist-Tuple{StatsBase.Histogram{<:Any, 1}, Tuple{Real, Real}}","page":"LegendSpecFits","title":"LegendSpecFits.subhist","text":"subhist(h::Histogram, r::Tuple{<:Real,<:Real})\n\nReturn a new Histogram with the bins in the range r.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.tuple_to_array-Tuple{NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.tuple_to_array","text":"tuple_to_array(nt::NamedTuple, fields::Vector{Symbol})\n\nReturn an array with the values of the fields in nt in the order given by fields.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.weibull_from_mx","page":"LegendSpecFits","title":"LegendSpecFits.weibull_from_mx","text":"weibull_from_mx(m::Real, x::Real, p_x::Real = 0.6827)::Weibull\n\nConstruct a Weibull distribution with a given median m and a given p_x-quantile x.\n\nUseful to construct priors for positive quantities.\n\n\n\n\n\n","category":"function"},{"location":"examples/detector_geometries/#Using-SolidStateDetectors-with-LegendDataManagment","page":"Detector Geometries","title":"Using SolidStateDetectors with LegendDataManagment","text":"","category":"section"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"LegendDataManagment is integrated with for SolidStateDetectors. This makes it possible to create SolidStateDetector instances from LEGEND metadata.","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"Example (requires a $LEGEND_DATA_CONFIG environment variable pointing to a LEGEND data-config file, replace V99000A with a valid detector name):","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"using Juleana, SolidStateDetectors, Plots\ndet = SolidStateDetector(LegendData(:l200), :V99000A)\nplot(det)","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"A detector can also be constructed using the filename of the LEGEND metadata detector-datasheet JSON file (no $LEGEND_DATA_CONFIG required):","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"det = SolidStateDetector(LegendData, \"V99000A.json\")","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"The following code will generate an overview plot of every 5th LEGEND detector (requires the actual LEGEND metadata instead of the metadata in legend-testdata):","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"using Juleana, SolidStateDetectors, Plots\nl200 = LegendData(:l200)\ndetnames = propertynames(l200.metadata.hardware.detectors.germanium.diodes)\nplot(\n    plot.(SolidStateDetector.(Ref(l200), detnames[1:5:120]))...,\n    layout = (3,8), lw = 0.05, legend = false, grid = false, showaxis = false,\n    xlims = (-0.05,0.05), ylims = (-0.05,0.05), zlims = (0,0.1), size = (4000,1500)\n)","category":"page"},{"location":"packages/LegendDataTypes/#LegendDataTypes","page":"LegendDataTypes","title":"LegendDataTypes","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Also see LegendDataTypes on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendDataTypes/#Modules","page":"LegendDataTypes","title":"Modules","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Modules = [LegendDataTypes]\nOrder = [:module]","category":"page"},{"location":"packages/LegendDataTypes/#Types-and-constants","page":"LegendDataTypes","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Modules = [LegendDataTypes]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendDataTypes/#Functions-and-macros","page":"LegendDataTypes","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Modules = [LegendDataTypes]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendDataTypes/#Documentation","page":"LegendDataTypes","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Modules = [LegendDataTypes]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendDataTypes/#LegendDataTypes.RadwareSigcompress","page":"LegendDataTypes","title":"LegendDataTypes.RadwareSigcompress","text":"RadwareSigcompress <: AbstractArrayCodec\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataTypes/#LegendDataTypes.TableLike","page":"LegendDataTypes","title":"LegendDataTypes.TableLike","text":"TableLike = AbstractVector{<:NamedTuple}\n\nThe type must also support the Tables.jl interface.\n\nExamples are TypedTables.Table and StructArrays.StructArray\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataTypes/#Base.getindex-Tuple{AbstractLegendInput, AbstractString, Vararg{Any}}","page":"LegendDataTypes","title":"Base.getindex","text":"getindex(input::AbstractLegendInput, key::AbstractString)\ngetindex(input::AbstractLegendInput, key::AbstractString, idxs::AbstractVector)\n\nGet object at key from input.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#Base.getindex-Tuple{LegendNullOutput, Any, AbstractString, Vararg{Any}}","page":"LegendDataTypes","title":"Base.getindex","text":"setindex!(output::AbstractLegendOutput, key::AbstractString)\ngetindex(output::AbstractLegendOutput, key::AbstractString, idxs::AbstractVector)\n\nGet object at key from input.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.chname2int-Tuple{AbstractString}","page":"LegendDataTypes","title":"LegendDataTypes.chname2int","text":"chname2int(channel_string::AbstractString)::Integer\n\nConvert a channel name string, as used in LEGEND data files to an integer channel number.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.decode_data","page":"LegendDataTypes","title":"LegendDataTypes.decode_data","text":"decode_data(data)\n\nDecode any encoded arrays present in (possibly nested) data.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.fast_flatten","page":"LegendDataTypes","title":"LegendDataTypes.fast_flatten","text":"fast_flatten(vector_of_arrays)\n\nFlattens a vector of arrays into a single array, by concatenating the inner arrays along the last dimension.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.filter_raw_data_by_energy-Tuple{AbstractVector{<:NamedTuple}, Function, AbstractDict{Symbol, <:IntervalSets.AbstractInterval{<:Number}}}","page":"LegendDataTypes","title":"LegendDataTypes.filter_raw_data_by_energy","text":"filter_raw_data_by_energy(\n    raw_data::TableLike,\n    calib_func::Function,\n    energy_windows::AbstractDict{Symbol,<:AbstractInterval{<:Number}}\n)::IDDict{Symbol,<:Any}\n\nFilter the table raw data, selecing only events in the energy intervals in values(energy_windows).\n\nThe selection is based on DAQ energy reconstruction and the energy calibration function calib_func.\n\nReturns a dicts of raw data tables with the same keys as energy_windows.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.flatten_by_key-Tuple{AbstractVector{<:IdDict{<:Any, <:AbstractVector}}}","page":"LegendDataTypes","title":"LegendDataTypes.flatten_by_key","text":"flatten_by_key(data::AbstractVector{<:IdDict{<:Any, <:AbstractVector}})::IdDict\n\nFlattens a vector of IdDicts into a single IdDict, by concatenating the entries for each key separately.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.get_all_channels-Tuple{AbstractDict{<:AbstractString}}","page":"LegendDataTypes","title":"LegendDataTypes.get_all_channels","text":"get_all_channels(ds::AbstractDict{<:AbstractString,<:Any})::AbstractVector{<:Integer}\n\nGet the channel numbers for all channels in datastore.\n\nChannels are identified as keys starting with \"ch...\", according to LEGEND convention. datastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore.\n\nChannel named are mapped to integer channel numbers via chname2int.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.get_daqenergy-Tuple{AbstractDict{<:AbstractString}, Integer}","page":"LegendDataTypes","title":"LegendDataTypes.get_daqenergy","text":"get_daqenergy(datastore::AbstractDict{<:AbstractString,<:Any}, ch::Integer)::AbstractVector{<:Integer}\n\nGet the daq energy reconstruction contained in the raw data of channel ch in datastore.\n\ndatastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore. Channel numbers are mapped to channel names via int2chname.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.get_raw_ch_data-Tuple{AbstractDict{<:AbstractString}, Integer}","page":"LegendDataTypes","title":"LegendDataTypes.get_raw_ch_data","text":"get_raw_ch_data(ds::AbstractDict{<:AbstractString,<:Any}, ch::Integer)::TableLike\n\nGet the raw data table for channel ch in datastore.\n\ndatastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore. Channel numbers are mapped to channel names via int2chname.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.getunits","page":"LegendDataTypes","title":"LegendDataTypes.getunits","text":"getunits(x)\n\nGet the units of x, falls back to Unitful.unit(x) if no specialized method is defined for the type of x.\n\nLEGEND I/O packages shoud add methods for the I/O-object types they handle.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.int2chname-Tuple{Any}","page":"LegendDataTypes","title":"LegendDataTypes.int2chname","text":"int2chname(channel_number::Integer)::AbstractString\n\nConvert an integer channel number to a channel name string as used in LEGEND data files.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.map_chunked-Tuple{Any, Any, Integer}","page":"LegendDataTypes","title":"LegendDataTypes.map_chunked","text":"map_chunked(f, table, chunk_size::Integer)\n\nMaps a function f over a table in chunks of size chunk_size.\n\nCalls getindex with contiguous index ranges, and so is also efficient for disk-based arrays and similar arrays with slow serial indexing but fast block-wise indexing.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.read_from_properties","page":"LegendDataTypes","title":"LegendDataTypes.read_from_properties","text":"read_from_properties(read_property::Function, src::Any, ::Type{T}) where {T<:AbstractArrayCodec}\n\nCreate a array codec of type T from properties of src, using the src-specific function read_property(src, name::Symbol, default_value) to read each property required.\n\nReturns an value of type T.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.readdata","page":"LegendDataTypes","title":"LegendDataTypes.readdata","text":"readdata(input, SomeDataType::Type)\n\nRead a value of type SomeDataType from input.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.setunits!","page":"LegendDataTypes","title":"LegendDataTypes.setunits!","text":"setunits!(x)\n\nSet the units of x.\n\nLEGEND I/O packages will need to add methods for the I/O-object types they handle.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.similar_table","page":"LegendDataTypes","title":"LegendDataTypes.similar_table","text":"LegendDataTypes.similar_table(orig_tbl::AbstractVector{<:NamedTuple{names}}, cols::NamedTuple{names})\n\nReturn a table similar to orig_tbl from columns cols.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.to_properties","page":"LegendDataTypes","title":"LegendDataTypes.to_properties","text":"write_to_properties!(write_property!::Function, dest::Any, codec::AbstractArrayCodec)\n\nWrite all information required to re-create codec to dest using thes dest-specific function write_property!(dest, name::Symbol, x).\n\nTypically returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.writedata","page":"LegendDataTypes","title":"LegendDataTypes.writedata","text":"readdata(input, x::SomeDataType)\n\nWrite a value x to output.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP","page":"LegendDSP","title":"LegendDSP","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Also see LegendDSP on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendDSP/#Modules","page":"LegendDSP","title":"Modules","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Modules = [LegendDSP]\nOrder = [:module]","category":"page"},{"location":"packages/LegendDSP/#Types-and-constants","page":"LegendDSP","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Modules = [LegendDSP]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendDSP/#Functions-and-macros","page":"LegendDSP","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Modules = [LegendDSP]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendDSP/#Documentation","page":"LegendDSP","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Modules = [LegendDSP]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendDSP/#LegendDSP.LegendDSP","page":"LegendDSP","title":"LegendDSP.LegendDSP","text":"LegendDSP\n\nTemplate for Julia packages.\n\n\n\n\n\n","category":"module"},{"location":"packages/LegendDSP/#LegendDSP.DSPConfig","page":"LegendDSP","title":"LegendDSP.DSPConfig","text":"DSPConfig{T <: Real}\n\nConfiguration parameters for DSP algorithms.\n\nFields\n\nenc_pickoff::Quantity{<:T}: pick-off time for ENC noise calculations\nbl_window::ClosedInterval{Quantity{<:T}}: fit window for basline extraction\ntail_window::ClosedInterval{Quantity{<:T}}: fit window for decay time extraction\ninTraceCut_std_threshold::T: in-trace pile-up rejector threshold in standard deviations\nt0_threshold::T: ADC threshold for t0 determination\ne_grid_rt_trap::StepRangeLen{Quantity{<:T}}: rise time grid scan range for trapezoidal filter\ne_grid_ft_trap::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for trapezoidal filter\ne_grid_rt_zac::StepRangeLen{Quantity{<:T}}: rise time grid scan range for ZAC filter\ne_grid_ft_zac::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for ZAC filter\ne_grid_rt_cusp::StepRangeLen{Quantity{<:T}}: rise time grid scan range for CUSP filter\ne_grid_ft_cusp::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for CUSP filter\na_grid_rt_sg::StepRangeLen{Quantity{<:T}}: window length grid scan range for SG filter\n\nExamples\n\nusing LegendDSP\nusing LegendDataManagement\n\nl200 = LegendData(:l200)\nfilekey = start_filekey(l200, (:p03, :r000, :cal))\ndsp_config = DSPConfig(dataprod_config(l200).dsp(filekey).default)\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP.IntersectMaximum","page":"LegendDSP","title":"LegendDSP.IntersectMaximum","text":"struct IntersectMaximum <: Function\n\nFinds the intersects of a Y with a threshold and picking the maximum in a given time window. Constructors:\n\nIntersectMaximum(; fields...)\n\nFields:\n\nmintot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: minimum time-over-threshold\nmaxtot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: maximum time-over-threshold for max to appear\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP.ModifiedSincFilter","page":"LegendDSP","title":"LegendDSP.ModifiedSincFilter","text":"struct ModifiedSincFilter{T<:RealQuantity} <: AbstractRadFIRFilter{}\n\nA Modified-Sinc filter Working example\n\nusing RadiationDetectorSignals\nusing Unitful\n\nn = 600\nnoise = 1.\nt = range(0u\"μs\", 20u\"μs\", 2*n)\nsignal = vcat(zeros(n), 10*ones(n)) + (noise*rand(2*n) .- noise/2)\nwf = RDWaveform(t, signal)\n\n# define filter parameters and filter\nflt = ModifiedSincFilter(d=4, m=1u\"μs\")\n\n# apply filter to signal\nwf_new = flt(wf)\n\nConstructors:\n\nModifiedSincFilter(; fields...)\n\nFields:\n\nd::Int64: degree of the filter determining the number of extrema in the kernel\nm::Union{Real, Unitful.AbstractQuantity{<:Real}}: half-width of the kernel\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP.MovingWindowFilter","page":"LegendDSP","title":"LegendDSP.MovingWindowFilter","text":"struct MovingWindowFilter <: AbstractRadFIRFilter\n\napply left moving average window to signal. The exact computations are:\n        yₙ = yₙ₋₁ + (xₙ - x₁)/l,    for n ∈ {1, …, l}\n        yₙ = yₙ₋₁ + (xₙ - xₙ₋ₗ)/l,    for n ∈ {l+1, …, L}\n\n\nConstructors:\n\nMovingWindowFilter(; fields...)\n\nFields:\n\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: length of the moving average window\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP.MovingWindowMultiFilter","page":"LegendDSP","title":"LegendDSP.MovingWindowMultiFilter","text":"struct MovingWindowMultiFilter <: AbstractRadFIRFilter\n\napply left and right moving average windows to signal. Working example:\n\nusing RadiationDetectorSignals\nusing Unitful\n\nsignal = rand(100)\nt = range(0u\"ms\", 20u\"ms\", 100)\n\nwf = RDWaveform(t, signal)\nflt = MovingWindowMultiFilter(1u\"ms\")\nwf_new = flt(wf)\n\nConstructors:\n\nMovingWindowMultiFilter(; fields...)\n\nFields:\n\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: size of the moving average window\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP.MultiIntersect","page":"LegendDSP","title":"LegendDSP.MultiIntersect","text":"struct MultiIntersect <: Function     Finds the x values at which a signal exceeds the provided      threshold_ratios the first time.      Constructors:     * MultiIntersect(; fields...)     Fields:\n\nthreshold_ratios::Vector{Float64}: ratios which determine the thresholds\nmintot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: minimum time-over-threshold\nn::Int64: half window length of polynomial fit\nd::Int64: degree of polynomial\nsampling_rate::Int64: upsampling rate\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP.WeightedSavitzkyGolayFilter","page":"LegendDSP","title":"LegendDSP.WeightedSavitzkyGolayFilter","text":"struct WeightedSavitzkyGolayFilter{T<:RealQuantity} <: AbstractRadFIRFilter\n\nA Weighted-Savitzky-Golay filter. Working example:\n\nusing RadiationDetectorSignals\nusing Unitful\n\nn = 600\nnoise = 1.\nt = range(0u\"μs\", 20u\"μs\", 2*n)\nsignal = vcat(zeros(n), 10*ones(n)) + (noise*rand(2*n) .- noise/2)\nwf = RDWaveform(t, signal)\n\n# define filter parameters and filter\nflt = WeightedSavitzkyGolayFilter(length=1u\"μs\", degree=3, weightType=2)\n\n# apply filter to signal\nwf_new = flt(wf)\n\nConstructors:\n\nWeightedSavitzkyGolayFilter(; fields...)\n\nFields:\n\nlength::Union{Real, Unitful.AbstractQuantity{<:Real}}: total filter length\ndegree::Int64: Polynomial degree\nweightType::Int64: weight function to use\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP.WhittakerHendersonFilter","page":"LegendDSP","title":"LegendDSP.WhittakerHendersonFilter","text":"struct WhittakerHendersonFilter <: AbstractRadSigFilter{LinearFiltering}\n\nA Whittaker-Henderson filter. Working example: ```julia using RadiationDetectorSignals using Unitful\n\nn = 600 noise = 1. t = range(0u\"μs\", 20u\"μs\", 2n) signal = vcat(zeros(n), 10ones(n)) + (noiserand(2n) .- noise/2) wf = RDWaveform(t, signal)\n\ndefine filter parameters and filter\n\nflt = WhittakerHendersonFilter(p=3, λ=4)\n\napply filter to signal\n\nwf_new = flt(wf)\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP._create_dsp_config-Tuple{PropDicts.PropDict}","page":"LegendDSP","title":"LegendDSP._create_dsp_config","text":"_create_dsp_config(dsp_metadata::PropDicts.PropDict)\n\nCreate a DSPConfig from a PropDict of DSP metadata.\n\nArguments\n\ndsp_metadata::PropDicts.PropDict: DSP metadata\n\nReturns\n\ndsp_config::DSPConfig: DSP configuration\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.banded_cholesky_solve!-Tuple{AbstractVector, AbstractMatrix, AbstractVector}","page":"LegendDSP","title":"LegendDSP.banded_cholesky_solve!","text":"banded_cholesky_solve!(x::AbstractVector, A::AbstractMatrix, y::AbstractVector)\n\nsolve the linear equation AA'x = y and store the result in x, where A is the cholesky decomposition of a banded centro symmetric matrix. A[1, i] is the diagonal, A[2, i] is the first subdiagonal and so on.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.choleskyL!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"LegendDSP","title":"LegendDSP.choleskyL!","text":"choleskyL!(b::AbstractMatrix{T})\n\ninplace cholesky decomposition of a banded symmetric matrix, where  b[1, i] contains the diagonal elements, b[2, i] the elements of the  first subdiagonal and so on.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_cusp_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_cusp_ft_optimization","text":"dsp_cusp_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given CUSP grid rise times while varying the flat-top time.\n\nReturns\n\n- `e_grid`: Array energy values for the given CUSP rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_cusp_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_cusp_rt_optimization","text":"dsp_cusp_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given CUSP grid rise times.\n\nReturns\n\n- `enc_cusp_grid`: Array ENC noise values for the given CUSP rise time grid\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_decay_times-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, IntervalSets.ClosedInterval{<:Union{Unitful.Quantity{var\"#s91\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s91\", 𝐓, U}} where {L, S}} where {var\"#s91\"<:T, U}}, IntervalSets.ClosedInterval{<:Union{Unitful.Quantity{var\"#s89\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s89\", 𝐓, U}} where {L, S}} where {var\"#s89\"<:T, U}}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_decay_times","text":"dsp_decay_times(wvfs::ArrayOfRDWaveforms, bl_window::ClosedInterval{<:Unitful.Time{<:T}}, tail_window::ClosedInterval{<:Unitful.Time{<:T}})\ndsp_decay_times(wvfs::ArrayOfRDWaveforms, config::DSPConfig)\n\nGet statistics on the logarhithmic of the tail of the wvfs in the interval tail_window.\n\nReturns\n\nτ: decay time in µs\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_icpc-Union{Tuple{T}, Tuple{Q}, Tuple{Q, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where {Q<:TypedTables.Table, T<:Real}","page":"LegendDSP","title":"LegendDSP.dsp_icpc","text":"dsp_icpc(data::Q, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where {Q <: Table, T<:Real}\n\nDSP for ICPC detectors. It needs the decay time τ of the detector and the filter parameters pars_filter for the optimal filter parameters for the Trap, CUSP and ZAC filter. \n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline from FADC\ntimestamp: timestamp from FADC\neventnumber: event ID from FADC\ndaqenergy: energy from FADC\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\ntailmean: tail mean after PZ correction\ntailsigma: tail sigma after PZ correction\ntailslope: tail slope after PZ correction\ntailoffset: tail offset after PZ correction\nt0: start time of waveform drift\nt10: timepoint of 10% of waveform maximum\nt50: timepoint of 50% of waveform maximum\nt80: timepoint of 80% of waveform maximum\nt90: timepoint of 90% of waveform maximum\nt99: timepoint of 99% of waveform maximum\nt50_current: timepoint of current rise to 50% of maximum\ntail_τ: tail decay time\ntail_mean: tail mean before PZ correction\ntail_sigma: tail sigma before PZ correction\ne_max: maximum of waveform\ne_min: minimum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313: energy of waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\ne_10410_inv: maximum of inverted waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313_inv: maximum of inverted waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\nt0_inv: start time of inverted waveform drift\ne_trap: energy of waveform with trapezoidal filter of optimized rise and flat-top time\ne_cusp: energy of waveform with CUSP filter of optimized rise and flat-top time\ne_zac: energy of waveform with ZAC filter of optimized rise and flat-top time\nqdrift: Q-drift parameter\nlq: LQ parameter\na: current maximum with optimal Savitzky-Golay filter length parameter\nblfc: baseline from FADC\ntimestamp: timestamp from FADC\neventID_fadc: event ID from FADC\ne_fc: energy from FADC\npretrace_diff: difference between first sample and baseline mean\ndrift_time: drift time between t0 and 90% of waveform maximum\ninTrace_intersect: position of in-trace pile-up\ninTrace_n: multiplicity of in-trace pile-up\nn_sat_low: number of samples the waveform is saturated at low of FADC range\nn_sat_high: number of samples the waveform is saturated at high of FADC range\nn_sat_low_cons: number of consecutive samples the waveform is saturated at low of FADC range\nn_sat_high_cons: number of consecutive samples the waveform is saturated at high of FADC range\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_icpc_compressed-Union{Tuple{T}, Tuple{Q}, Tuple{Q, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where {Q<:TypedTables.Table, T<:Real}","page":"LegendDSP","title":"LegendDSP.dsp_icpc_compressed","text":"dsp_icpc_compressed(data::Q, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where {Q <: Table, T<:Real}\n\nDSP for ICPC detectors. It needs the decay time τ of the detector and the filter parameters pars_filter for the optimal filter parameters for the Trap, CUSP and ZAC filter. \n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline from FADC\ntimestamp: timestamp from FADC\neventnumber: event ID from FADC\ndaqenergy: energy from FADC\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\ntailmean: tail mean after PZ correction\ntailsigma: tail sigma after PZ correction\ntailslope: tail slope after PZ correction\ntailoffset: tail offset after PZ correction\nt0: start time of waveform drift\nt10: timepoint of 10% of waveform maximum\nt50: timepoint of 50% of waveform maximum\nt80: timepoint of 80% of waveform maximum\nt90: timepoint of 90% of waveform maximum\nt99: timepoint of 99% of waveform maximum\nt50_current: timepoint of current rise to 50% of maximum\ntail_τ: tail decay time\ntail_mean: tail mean before PZ correction\ntail_sigma: tail sigma before PZ correction\ne_max: maximum of waveform\ne_min: minimum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313: energy of waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\ne_10410_inv: maximum of inverted waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313_inv: maximum of inverted waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\nt0_inv: start time of inverted waveform drift\ne_trap: energy of waveform with trapezoidal filter of optimized rise and flat-top time\ne_cusp: energy of waveform with CUSP filter of optimized rise and flat-top time\ne_zac: energy of waveform with ZAC filter of optimized rise and flat-top time\nqdrift: Q-drift parameter\nlq: LQ parameter\na: current maximum with optimal Savitzky-Golay filter length parameter\nblfc: baseline from FADC\ntimestamp: timestamp from FADC\neventID_fadc: event ID from FADC\ne_fc: energy from FADC\npretrace_diff: difference between first sample and baseline mean\ndrift_time: drift time between t0 and 90% of waveform maximum\ninTrace_intersect: position of in-trace pile-up\ninTrace_n: multiplicity of in-trace pile-up\nn_sat_low: number of samples the waveform is saturated at low of FADC range\nn_sat_high: number of samples the waveform is saturated at high of FADC range\nn_sat_low_cons: number of consecutive samples the waveform is saturated at low of FADC range\nn_sat_high_cons: number of consecutive samples the waveform is saturated at high of FADC range\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_puls-Union{Tuple{Q}, Tuple{Q, DSPConfig}} where Q<:TypedTables.Table","page":"LegendDSP","title":"LegendDSP.dsp_puls","text":"dsp_puls(data::Q, config::DSPConfig) where {Q <: Table}\n\nDSP function for pulser processing.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\nt50: timepoint of 50% of waveform maximum\ne_max: maximum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_qc_flt_optimization-Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Union{Unitful.Quantity{var\"#s95\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s95\", 𝐓, U}} where {L, S}} where {var\"#s95\"<:Real, U}, Function}","page":"LegendDSP","title":"LegendDSP.dsp_qc_flt_optimization","text":"dsp_flt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Unitful.Time{<:Real}, f_evaluate_qc::Function)\n\nGet QC DSP for filter parameter optimization for a given waveform set.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_qc_flt_optimization_compressed-Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Union{Unitful.Quantity{var\"#s95\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s95\", 𝐓, U}} where {L, S}} where {var\"#s95\"<:Real, U}, Function}","page":"LegendDSP","title":"LegendDSP.dsp_qc_flt_optimization_compressed","text":"dsp_qc_flt_optimization_compressed(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Unitful.Time{<:Real}, f_evaluate_qc::Function)\n\nGet QC DSP for filter parameter optimization for a given waveform set.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_qdrift_flt_optimization-Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Vector{<:Real}, DSPConfig, Union{Unitful.Quantity{var\"#s93\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s93\", 𝐓, U}} where {L, S}} where {var\"#s93\"<:Real, U}}","page":"LegendDSP","title":"LegendDSP.dsp_qdrift_flt_optimization","text":"dsp_qdrift_flt_optimization(wvfs::ArrayOfRDWaveforms, blmean::Vector{<:Real}, config::DSPConfig, τ::Unitful.Time{<:Real})\n\nGet QDrift filter parameter optimization for a given waveform set.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_sg_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_sg_optimization","text":"dsp_sg_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where T<:Real\n\nOptimize the Savitzky-Golay filter parameters for a given waveform set.\n\nReturns\n\n- `aoe`: Array of efficiency values for the given Savitzky-Golay filter parameters\n- `e`: Array of energy values for the given Savitzky-Golay filter parameters\n- `blmean`: Baseline mean value\n- `blslope`: Baseline slope value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_sg_optimization_compressed-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_sg_optimization_compressed","text":"dsp_sg_optimization_compressed(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where T<:Real\n\nOptimize the Savitzky-Golay filter parameters for a given waveform set.\n\nReturns\n\n- `aoe`: Array of efficiency values for the given Savitzky-Golay filter parameters\n- `e`: Array of energy values for the given Savitzky-Golay filter parameters\n- `blmean`: Baseline mean value\n- `blslope`: Baseline slope value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_sipm-Union{Tuple{Q}, Tuple{Q, PropDicts.PropDict, PropDicts.PropDict}} where Q<:TypedTables.Table","page":"LegendDSP","title":"LegendDSP.dsp_sipm","text":"dsp_sipm(data::Q, config::PropDict, pars_threshold::PropDict)\n\nDSP routine for SiPM data. It needs the threshold parameters from the threshold scan for the given SiPM channel as well as the discharge threshold parameters.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\ntrig_pos: trigger positions from DSP\ntrig_max: trigger maxima from DSP\ntrig_pos_DC: trigger positions of discharges\ntrig_max_DC: trigger maxima of discharges\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_sipm_compressed-Union{Tuple{Q}, Tuple{Q, PropDicts.PropDict, PropDicts.PropDict}} where Q<:TypedTables.Table","page":"LegendDSP","title":"LegendDSP.dsp_sipm_compressed","text":"dsp_sipm_compressed(data::Q, config::PropDict, pars_threshold::PropDict)\n\nDSP routine for SiPM data. It needs the threshold parameters from the threshold scan for the given SiPM channel as well as the discharge threshold parameters.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\ntrig_pos: trigger positions from DSP\ntrig_max: trigger maxima from DSP\ntrig_pos_DC: trigger positions of discharges\ntrig_max_DC: trigger maxima of discharges\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_sipm_thresholds_compressed-Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, PropDicts.PropDict}","page":"LegendDSP","title":"LegendDSP.dsp_sipm_thresholds_compressed","text":"dsp_sipm_thresholds_compressed(wvfs::ArrayOfRDWaveforms, config::PropDict)\n\nThis function calculates the baseline of the waveforms and the baseline of the waveforms with the sign flipped. The function is used to calculate the thresholds for the SiPMs.\n\nArguments\n\nwvfs::ArrayOfRDWaveforms: Array of RDWaveforms\nconfig::PropDict: Configuration parameters\n\nReturns\n\nTable: Table with the baseline of the waveforms and the baseline of the waveforms with the sign flipped\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_trap_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_trap_ft_optimization","text":"dsp_trap_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given trap grid rise times while varying the flat-top time.\n\nReturns\n\n- `e_grid`: Array energy values for the given trap rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_trap_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_trap_rt_optimization","text":"dsp_trap_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given trap grid rise times.\n\nReturns\n\n- `enc_trap_grid`: Array ENC noise values for the given trap rise time grid\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_zac_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_zac_ft_optimization","text":"dsp_zac_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given ZAC grid rise times while varying the flat-top time.\n\nReturns:     - e_grid: Array energy values for the given ZAC rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_zac_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_zac_rt_optimization","text":"dsp_zac_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given ZAC grid rise times.\n\nReturns\n\n- `enc_zac_grid`: Array ENC noise values for the given ZAC rise time grid\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.extrema3points-Union{Tuple{T}, Tuple{T, T, T}} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real)","page":"LegendDSP","title":"LegendDSP.extrema3points","text":"extrema3points(y1::T,y2::T,y3::T)::T where {T<:AbstractFloat}\n\nCalculate the extrema of a parabola defined by three points.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.get_intracePileUp-Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Real, IntervalSets.ClosedInterval{<:Union{Unitful.Quantity{var\"#s87\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s87\", 𝐓, U}} where {L, S}} where {var\"#s87\"<:Real, U}}}","page":"LegendDSP","title":"LegendDSP.get_intracePileUp","text":"get_intracePileUp(wvfs::ArrayOfRDWaveforms, sigma_threshold::Real, bl_window::ClosedInterval{<:Unitful.Time{<:Real}}; mintot::Unitful.Time=100.0u\"ns\")\n\nGet position and multiplicity of in-trace pile-up as intersect of reversed derivative signal with threshold as multiple of std. The wvfs have to be a current signal.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.get_qc_classifier","page":"LegendDSP","title":"LegendDSP.get_qc_classifier","text":"get_qc_classifier(wvfs::ArrayOfRDWaveforms, f_evaluate_qc::Function)\n\nGet a classifier for quality cuts using the given waveforms and evaluation function which evulates a predefined SVM model.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP.get_qc_classifier_compressed","page":"LegendDSP","title":"LegendDSP.get_qc_classifier_compressed","text":"get_qc_classifier_compressed(wvfs::ArrayOfRDWaveforms, f_evaluate_qc::Function)\nget_qc_classifier_compressed(wvfs::ArrayOfRDWaveforms, f_evaluate_qc::Function, config::DSPConfig)\n\nGet a classifier for quality cuts using the given waveforms and evaluation function which evulates a predefined SVM model.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP.get_qc_ml_func-Tuple{Matrix{<:Real}, Vector{<:Real}, PropDicts.PropDict}","page":"LegendDSP","title":"LegendDSP.get_qc_ml_func","text":"get_qc_ml_func(dwts_norm::Matrix{<:Real}, dc_labels::Vector{<:Real}, hyperparams::PropDict)\n\nCreate a function that takes a signal and returns the prediction using the given hyperparameters and discrete wavelet transforms.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.get_qdrift-Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Array{<:Union{Unitful.Quantity{var\"#s81\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s81\", 𝐓, U}} where {L, S}} where {var\"#s81\"<:Real, U}}, StepRangeLen{<:Union{Unitful.Quantity{var\"#s79\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s79\", 𝐓, U}} where {L, S}} where {var\"#s79\"<:Real, U}}}","page":"LegendDSP","title":"LegendDSP.get_qdrift","text":"get_qdrift(wvfs::ArrayOfRDWaveforms, t_start::Array{Unitful.Time{T}}, Δt::UnitRange{Unitful.Time{T}}; pol_power::Int=3, sign_est_length::Unitful.Time=100u\"ns\")\n\nGet the Q-drift parameter for each waveform in wvfs by integrating the waveform with gain = 1 and using a polynomial signal estimator of order pol_power and length sign_est_length to estimate the signal.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.get_t0-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, T}} where T<:Real","page":"LegendDSP","title":"LegendDSP.get_t0","text":"get_t0(wvfs_pz::ArrayOfRDWaveforms, t0_threshold::T) where T<:Real\n\nGet t0 for each waveform in wvfs_pz by using a fast asymetric trapezoidal filter and a fixed threshold at t0_threshold. The filter is truncated to the range 0µs to 60µs where the Ge trigger is expected in FlashCam.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.get_threshold-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Union{Array{T}, T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.get_threshold","text":"get_threshold(wvfs::ArrayOfRDWaveforms, threshold::Array{T}) where T<:Real\n\nGet threshold for each waveform in wvfs by intersecting the waveform with a threshold per waveform or globally.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.get_wvf_maximum","page":"LegendDSP","title":"LegendDSP.get_wvf_maximum","text":"get_wvf_maximum(signal::AbstractSamples, start::Real, stop::Real)\nget_wvf_maximum(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet the maximum of a signal in the interval (start,stop) by quadaratic interpolation.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP.makeFitWeights-Union{Tuple{U}, Tuple{U, Int64}} where U<:Integer","page":"LegendDSP","title":"LegendDSP.makeFitWeights","text":"makeFitWeights(d::Int, m::Int) where {U}\n\nreturn the weights for the linear fit user for linear extrapolation at  at the right boundary.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.makeIPlusLambdaDprimeD-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T","page":"LegendDSP","title":"LegendDSP.makeIPlusLambdaDprimeD","text":"makeIPlusLambdaDprimeD(λ::T, p::Int, N::Int) where {T}\n\nbuild the centro symmetric banded matrix which needs to be inverted  later: I + λ*D'D D is the finite difference matrix of order p.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.saturation","page":"LegendDSP","title":"LegendDSP.saturation","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop).\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP.tailstats","page":"LegendDSP","title":"LegendDSP.tailstats","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop) by fitting a linear function.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP.weighted_linear_reg-Tuple{AbstractVector, AbstractVector}","page":"LegendDSP","title":"LegendDSP.weighted_linear_reg","text":"weighted_linear_reg(w::AbstractVector, y::AbstractVector)\n\nDo a weighted linear regression of the data y with weights w and return the offset and slope. its assumed that x is a range from 1 to length(y)\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationSpectra/#RadiationSpectra","page":"RadiationSpectra","title":"RadiationSpectra","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Also see RadiationSpectra on GitHub and the full package documentation.","category":"page"},{"location":"packages/RadiationSpectra/#Modules","page":"RadiationSpectra","title":"Modules","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Modules = [RadiationSpectra]\nOrder = [:module]","category":"page"},{"location":"packages/RadiationSpectra/#Types-and-constants","page":"RadiationSpectra","title":"Types and constants","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Modules = [RadiationSpectra]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/RadiationSpectra/#Functions-and-macros","page":"RadiationSpectra","title":"Functions and macros","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Modules = [RadiationSpectra]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/RadiationSpectra/#Documentation","page":"RadiationSpectra","title":"Documentation","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Modules = [RadiationSpectra]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/RadiationSpectra/#RadiationSpectra._interpolate_linear-Tuple{Tuple{Real, Real}, Tuple{Real, Real}}","page":"RadiationSpectra","title":"RadiationSpectra._interpolate_linear","text":"_interpolate_linear(point1::Tuple{Real, Real}, point2::Tuple{Real, Real}; threshold::Real = 0.5)\n\nInterpolate a point between two points point1 and point2 using a linear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationSpectra/#RadiationSpectra.calibrate_spectrum-Tuple{StatsBase.Histogram{<:Real, 1}, Vector{<:Real}}","page":"RadiationSpectra","title":"RadiationSpectra.calibrate_spectrum","text":"calibrate_spectrum(h_uncal::Histogram, photon_lines::Array{Real, 1}; <keyword arguments>)\n\nReturns the calibrated histogram, the deconvoluted spectrum, the found (uncalibrated) peak positions and the final threshold value.\n\nKeywords\n\nσ::Real = 2.0: The expected sigma of a peak in the spectrum. In units of bins.\nthreshold::Real = 10.0: Threshold for being identified as a peak in the deconvoluted spectrum. A single bin is identified as a peak when its weight exceeds the threshold and the previous bin was not identified as an peak.\nmin_n_peaks::Int = 0: If the number of found peaks is smaller than min_n_peaks the functions lowers the parameter threshold until enough peaks are found.\nmax_n_peaks::Int = 50: Use only the first (strongest) max_n_peaks peaks for peak identification.\nα::Real = 0.005:  = 0.5%. Acceptance level in the comparison of the peak position ratios in the peak indentification step. When the difference between the ratio of two found peak positions and the ratio of two photon lines (photon_lines) is smaller than α, the found peaks are identified as the two photon lines.\nrtol::Real = 5e-3:  = 5e-3. Acceptance level for tolerance of the absolute difference between true and found line position.\n\nCalibrate the spectrum h_uncal. This is done by:\n\nfinding peaks through devoncolution\nidentifying them through comparison of the ratios of their positions with the ratios of the known lines\nfitting all identified peaks (with a gaussian plus first order polynomial) to get their position more precisely\nperforme a linear fit (offset forced to 0) of these positions vs the true positions (lines) to get the calibration constant\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationSpectra/#RadiationSpectra.get_example_spectrum-Tuple{}","page":"RadiationSpectra","title":"RadiationSpectra.get_example_spectrum","text":"get_example_spectrum()::Histogram\n\nReturns an uncalibrated radiation spectrum for testing and demonstrating purpose.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationSpectra/#RadiationSpectra.opt_fit","page":"RadiationSpectra","title":"RadiationSpectra.opt_fit","text":"# opt_fit(DT::Type{<:UvSpectrumDensity}, h::Histogram{<:Any, 1},\n         p0::NamedTuple, lower_bounds::NamedTuple, upper_bounds::NamedTuple)\n\nMaximum Likelihood Estimation Fit of model density d on the histogram h.     \n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationSpectra/#RadiationSpectra.opt_fit-2","page":"RadiationSpectra","title":"RadiationSpectra.opt_fit","text":"# opt_fit(DT::Type{<:UvSpectrumDensity}, h::Histogram{<:Any, 1},\n         p0::AbstractVector, lower_bounds::AbstractVector, upper_bounds::AbstractVector)\n\nMaximum Likelihood Estimation Fit of model density d on the histogram h.     \n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationSpectra/#RadiationSpectra.peakfinder-Tuple{StatsBase.Histogram}","page":"RadiationSpectra","title":"RadiationSpectra.peakfinder","text":"peakfinder(h::Histogram; <keyword arguments>)::Tuple{Histogram, Array{Float64, 1}}\n\nReturns a deconvoluted spectrum and an array of peak positions.\n\nKeywords\n\nσ::Real=2.0: The expected sigma of a peak in the spectrum. In units of bins. \nthreshold::Real=10.0: Threshold for being identified as a peak in the deconvoluted spectrum. A single bin is identified as a peak when its weight exceeds the threshold and the previous bin was not identified as an peak.\nbackgroundRemove::Bool=true\ndeconIterations::Int=3\nmarkov::Bool=true\naverWindow::Int=3\n\nSource\n\nThis function is basically a copy of TSpectrum::SearchHighRes from ROOT.\n\nM.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.\nM. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.\nZ.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Also see RadiationDetectorSignals on GitHub and the full package documentation.","category":"page"},{"location":"packages/RadiationDetectorSignals/#Modules","page":"RadiationDetectorSignals","title":"Modules","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Modules = [RadiationDetectorSignals]\nOrder = [:module]","category":"page"},{"location":"packages/RadiationDetectorSignals/#Types-and-constants","page":"RadiationDetectorSignals","title":"Types and constants","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Modules = [RadiationDetectorSignals]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/RadiationDetectorSignals/#Functions-and-macros","page":"RadiationDetectorSignals","title":"Functions and macros","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Modules = [RadiationDetectorSignals]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/RadiationDetectorSignals/#Documentation","page":"RadiationDetectorSignals","title":"Documentation","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Modules = [RadiationDetectorSignals]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals.ArrayOfRDWaveforms","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals.ArrayOfRDWaveforms","text":"ArrayOfRDWaveforms = StructArray{<:RDWaveform, ...)\n\nA StructsArrays.StructArray of RDWaveform.\n\nBy default, uses ArraysOfArrays.VectorOfVectors for contiguous memory layout.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals.DetectorHit","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals.DetectorHit","text":"DetectorHit = NamedTuple{(:evtno, :detno, :thit, :edep, :pos), ...)\n\nRepresentation of an localized energy deposition in a detector.\n\nUse DetectorHitEvents for arrays of DetectorHit that have a compact memory layout.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals.DetectorHitEvents","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals.DetectorHitEvents","text":"DetectorHitEvents = TypedTables.Table{...}\n\nA TypedTables.Table of DetectorHit events.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals.RDWaveform","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals.RDWaveform","text":"RDWaveform\n\nRepresents a radiation detector signal waveform.\n\nFields:\n\ntime: time axis, typically a range\nsignal: detector signal values\n\nUse ArrayOfRDWaveforms for arrays of RDWaveform that have a compact memory layout.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Also see LegendHDF5IO on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendHDF5IO/#Modules","page":"LegendHDF5IO","title":"Modules","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Modules = [LegendHDF5IO]\nOrder = [:module]","category":"page"},{"location":"packages/LegendHDF5IO/#Types-and-constants","page":"LegendHDF5IO","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Modules = [LegendHDF5IO]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendHDF5IO/#Functions-and-macros","page":"LegendHDF5IO","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Modules = [LegendHDF5IO]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendHDF5IO/#Documentation","page":"LegendHDF5IO","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Modules = [LegendHDF5IO]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array{T, N} <: AbstractArray{T, N}\n\nArray wrapper for HDF5.Datasets following the LEGEND data format as in \".lh5\" files. \n\nAn LH5Array contains a HDF5.Dataset file and Unitful.Unitlike units as  returned by getunits(file).getindexandappend!are supported.getindexessentially falls back togetindexforHDF5.Datasets,  enabling the user to always read in the desired part of an ondisk array without  having to load it in whole beforehand.append!` uses chunks to append the data provided to the ondisk array. It is important to note, that data is always appended along the last dimension of an  array\n\nDefault constructors\n\nLH5Array{T}(ds::HDF5.Dataset, u::Unitful.Unitlike)\nLH5Array{T, N}(ds::HDF5.Dataset)\nLH5Array(ds::Union{HDF5.Dataset, HDF5.H5DataStore})\n\n\nExamples:\n\njulia> using HDF5\njulia> f = h5open(\"path/to/lh5/file\", \"r\")\njulia> l5 = LH5Array(f[\"path/to/HDF5/Dataset\"])\n[...]\njulia> x = lh[1:10]     # load the first 10 elements of the ondisk array\n[...]\njulia> append!(lh, x)   # append those 10 elements to the ondisk array \n[...]\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:AbstractArray{<:Bool}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:AbstractArray{<:Bool}}) = begin\n\nreturn a LH5Array with dimensions equal to that of ds and element type  Bool. Applying getindex! on LH5Array{Bool} will yield a BitArray.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:AbstractArray{<:Tuple{Vararg{T, N}} where {N, T}}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:AbstractArray{<:Tuple}})\n\nreturn an Array of NTuples\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:AbstractArray}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:AbstractArray})\n\nreturn a LH5Array with dimensions equal to that of ds and element type  equal to eltype(ds) * u\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:ArraysOfArrays.AbstractArrayOfSimilarArrays{<:Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:AbstractArrayOfSimilarArrays{<:RealQuantity}})\n\nreturn an ArraysOfSimilarArrays where the field data is a LH5Array  (see ArraysOfSimilarArrays)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:Bool}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:Bool}) = begin\n\nreturn a value with type Bool\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:String}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:String})\n\nreturn a String.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:Symbol}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:Symbol})\n\nreturn a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:Tuple}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:Tuple})\n\nreturn an Tuple\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:RealQuantity})\n\nreturn a value with type RealQuantity\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:AbstractVector{<:AbstractVector}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.DataStore, ::Type{<:AbstractVector{<:AbstractVector{<:RealQuantity}}})\n\nreturn a VectorOfVectors object where data is an LH5Array  (see VectorOfArrays)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:AbstractVector{<:RDWaveform}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.DataStore, ::Type{<:AbstractVector{<:RDWaveform}})\n\nreturn an ArrayOfRDWaveforms where the field signal is either a  VectorOfSimilarVectors with an LH5Array as data or VectorOfVectors  with an LH5Array as data (see ArrayOfRDWaveforms and ArraysOfArrays) \n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:EncodedArrays.AbstractEncodedArray{T, 1} where T}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:AbstractEncodedArray{T, 1} where {T}})\n\nreturn an EncodedArray\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:EncodedArrays.VectorOfEncodedArrays{T, 1, C, VS} where {T, C<:EncodedArrays.AbstractArrayCodec, VS<:(AbstractVector{<:Tuple{var\"#s12\"} where var\"#s12\"<:Integer})}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:VectorOfEncodedArrays{T, 1} where {T}})\n\nreturn a VectorOfEncodedArrays\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:EncodedArrays.VectorOfEncodedSimilarArrays{T, 1} where T}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:VectorOfEncodedSimilarArrays{T, 1} where {T}})\n\nreturn a VectorOfEncodedSimilarArrays\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:StatsBase.Histogram{<:Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"\"     LH5Array(ds::HDF5.H5DataStore, ::Type{<:Histogram{<:RealQuantity}})\n\nreturn a Histogram. \n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Union{Tuple{T}, Tuple{HDF5.H5DataStore, Type{<:NamedTuple{T}}}} where T","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:NamedTuple{T}}) where T\n\nreturn a NamedTuple where each field is the output of LH5Array applied to it.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Union{Tuple{T}, Tuple{HDF5.H5DataStore, Type{<:TypedTables.Table{var\"#s18\", N} where {var\"#s18\"<:(NamedTuple{T}), N}}}} where T","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.DataStore, ::Type{<:TypedTables.Table{<:NamedTuple{(T)}}}) where T\n\nreturn a Table where each column is the output of LH5Array applied to it.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LHDataStore","page":"LegendHDF5IO","title":"LegendHDF5IO.LHDataStore","text":"LHDataStore <: AbstractDict{String,Any}\n\nDictionary wrapper for HDF5.H5DataStore objects, which were constructed  according to the LEGEND data format in \".lh5\" files. \n\nConstructor:\n\nLHDataStore(h5ds::HDF5.DataStore)\n\nThis return an LHDataStore object that wraps an h5ds which will typically be an HDF5.File be may also be an HDF5.H5DataStore (e.g. an HDF5.Group). in general.\n\nTo read or write \".lh5\" file directly (without using HDF5.h5open first), we recommend using lh5open.\n\nSupports getindex and setindex! where getindex(lh::LHDataStore, s) returns  the output of LH5Array applied to data_store[s] and setindex!  creates and writes HDF5.Groups and HDF5.Datasets using chunks of size 1000  to the ondisk array. Currently supported are objects with types: AbstractArray{<:RealQuantity}, ArraysOfSimilarArrays{<:RealQuantity},  VectorOfVectors{<:RealQuantity}, NamedTuple,TypedTables.Table,  Vector{<:RDWaveform}. For AbstractArray{<:RealQuantity} It is assumed  that the last axis of the provided array corresponds to the event number  index.\n\nExample\n\njulia> using HDF5\njulia> h5ds = h5open(\"path/to/lhf/file\")\njulia> lhf = LHDataStore(h5ds)\njulia> lhf[\"raw\"]\n[...]\njulia> using Unitful\njulia> x = rand(100) * u\"ns\"\njulia> lhf[\"new\"] = x\n[...]\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.add_entries!","page":"LegendHDF5IO","title":"LegendHDF5IO.add_entries!","text":"add_entries!(lhd::LHDataStore, i::AbstractString, src::NamedTuple, \n    dest::NamedTuple=LH5Array(lhd.data_store[i]))\n\nextend the NamedTuple dest at lhd[i] with elements from src.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.add_entries!-2","page":"LegendHDF5IO","title":"LegendHDF5IO.add_entries!","text":"add_entries!(lhd::LHDataStore, i::AbstractString, src::TypedTable.Table, \n    dest::TypedTable.Table=LH5Array(lhd.data_store[i]))\n\nextend the Table dest at lhd[i] with columns from src.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.delete_entry!-Tuple{LHDataStore, AbstractString}","page":"LegendHDF5IO","title":"LegendHDF5IO.delete_entry!","text":"delete_entry!(lhd::LHDataStore, i::AbstractString)\n\nremove the dataset lhd[i] and adjust the datatype of the parent if necessary.  Currently supported are elements of NamedTuple, TypedTable.Table or  HDF5.Group. \n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.lh5open","page":"LegendHDF5IO","title":"LegendHDF5IO.lh5open","text":"lh5open(f, filename::AbstractString, access::AbstractString = \"r\")\n\nReturn f(lh5open(f, filename, access)).\n\nOpens and closes the LEGEND HDF5 file filename automatically.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.lh5open-2","page":"LegendHDF5IO","title":"LegendHDF5IO.lh5open","text":"lh5open(filename::AbstractString, access::AbstractString = \"r\")\n\nOpen a LEGEND HDF5 file and return an LHDataStore object.\n\nLEGEND HDF5 files typically use the file extention \".lh5\".\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"packages/LegendDataManagement/#LegendDataManagement","page":"LegendDataManagement","title":"LegendDataManagement","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Also see LegendDataManagement on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendDataManagement/#Modules","page":"LegendDataManagement","title":"Modules","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Modules = [LegendDataManagement, LegendDataManagement.LDMUtils]\nOrder = [:module]","category":"page"},{"location":"packages/LegendDataManagement/#Types-and-constants","page":"LegendDataManagement","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Modules = [LegendDataManagement, LegendDataManagement.LDMUtils]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendDataManagement/#Functions-and-macros","page":"LegendDataManagement","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Modules = [LegendDataManagement, LegendDataManagement.LDMUtils]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendDataManagement/#Documentation","page":"LegendDataManagement","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Modules = [LegendDataManagement, LegendDataManagement.LDMUtils]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendDataManagement/#LegendDataManagement.AbstractSetupData","page":"LegendDataManagement","title":"LegendDataManagement.AbstractSetupData","text":"abstract type AbstractSetupData\n\nSubtypes wrap SetupConfig for specific experiments.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ChannelId","page":"LegendDataManagement","title":"LegendDataManagement.ChannelId","text":"struct ChannelId <: DataSelector\n\nRepresents a LEGEND data channel.\n\nExample:\n\nch = ChannelId(1083204)\n# ch = ChannelId(98) # with old channel numbering\nch.no == 1083204\nstring(ch) == \"ch1083204\"\nChannelId(\"ch1083204\") == ch\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataCategory","page":"LegendDataManagement","title":"LegendDataManagement.DataCategory","text":"struct DataCategory <: DataSelector\n\nRepresents a LEGEND data category (related to a DAQ/measuring mode) like \"cal\" or \"phy\".\n\nExample:\n\ncategory = DataCategory(:cal)\ncategory.label == :cal\nstring(category) == \"cal\"\nDataCategory(\"cal\") == category\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataPartition","page":"LegendDataManagement","title":"LegendDataManagement.DataPartition","text":"struct DataPartition <: DataSelector\n\nRepresents a LEGEND data-taking partition.\n\nExample:\n\npartition = DataPartition(1)\npartition.no == 1\nstring(partition) == \"partition01\"\nDataPartition(\"partiton01\") == partition\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataPeriod","page":"LegendDataManagement","title":"LegendDataManagement.DataPeriod","text":"struct DataPeriod <: DataSelector\n\nRepresents a LEGEND data-taking period.\n\nExample:\n\nperiod = DataPeriod(2)\nperiod.no == 2\nstring(period) == \"p02\"\nDataPeriod(\"p02\") == period\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataRun","page":"LegendDataManagement","title":"LegendDataManagement.DataRun","text":"struct DataRun <: DataSelector\n\nRepresents a LEGEND data-taking run.\n\nExample:\n\nr = DataRun(6)\nr.no == 6\nstring(r) == \"r006\"\nDataRun(\"r006\") == r\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataSelector","page":"LegendDataManagement","title":"LegendDataManagement.DataSelector","text":"abstract type DataSelector\n\nAbstract type for data selectors like ExpSetup, DataTier, DataPeriod, DataRun, DataCategory, Timestamp and FileKey.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataTier","page":"LegendDataManagement","title":"LegendDataManagement.DataTier","text":"struct DataTier <: DataSelector\n\nRepresents a LEGEND data tier like \"raw, \"dsp\", etc.\n\nExample:\n\ntier = DataTier(:raw)\ntier.label == :raw\nstring(tier) == \"raw\"\nDataTier(\"raw\") == tier\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DetectorId","page":"LegendDataManagement","title":"LegendDataManagement.DetectorId","text":"struct DetectorId <: DataSelector\n\nRepresents a LEGEND detector id id.\n\nExample:\n\ndetector = DetectorId(:V99000A)\ndetector.label == :V99000A\nstring(detector) == \"V99000A\"\nDetectorId(\"V99000A\") == detector\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ExpSetup","page":"LegendDataManagement","title":"LegendDataManagement.ExpSetup","text":"struct ExpSetup <: DataSelector\n\nRepresents a LEGEND experimental setup like \"l200\".\n\nExample:\n\nsetup = ExpSetup(:l200)\nsetup.label == :l200\nstring(setup) == \"l200\"\nExpSetup(\"l200\") == setup\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.FileKey","page":"LegendDataManagement","title":"LegendDataManagement.FileKey","text":"struct FileKey <: DataSelector\n\nRepresents a LEGEND file key.\n\nExample:\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nSee also read_filekeys and write_filekeys.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LegendData","page":"LegendDataManagement","title":"LegendDataManagement.LegendData","text":"struct LegendData <: AbstractSetupData\n\nProvides access to LEGEND data and metadata.\n\nConstructors:\n\nLegendData(setup_config::SetupConfig).\nLegendData(setup::Symbol) - requires the $LEGEND_DATA_CONFIG environment variable to be set.\n\nExamples:\n\nconfig_filename = \"/path/to/config.json\"\nconfig = LegendDataConfig(config_filename)\nl200 = LegendData(config.setups.l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nor simply (if $LEGEND_DATA_CONFIG is set):\n\nl200 = LegendData(:l200)\n\nLegendData has the (virtual) properties metadata and tier.\n\nThe full path to \"tier\" data files can be retrieved using\n\n(data::LegendData)[tier::Symbol, filekey::FileKey]\n(data::LegendData).tier[tier::Symbol, filekey::AbstractString]\n\nExample:\n\nl200.tier[:raw]\nl200.tier[:raw, FileKey(\"l200-p02-r006-cal-20221226T200846Z\")]\n\nLegendData comes with an extension for SolidStateDetectors:\n\nl200 = LegendData(:l200)\nSolidStateDetector(l200, :V99000A)\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LegendDataConfig","page":"LegendDataManagement","title":"LegendDataManagement.LegendDataConfig","text":"struct LegendDataConfig\n\nData configuration multiple experimental setups.\n\nContains a single field setups::PropertyDict{Symbol,SetupConfig}.\n\nCan be read from a config file via LegendDataConfig(config_filename[s]), or simply LegendDataConfig() if the environment variable $LEGEND_DATA_CONFIG is set. $LEGEND_DATA_CONFIG may be a list of colon-separated config filenames, which are applied/merged in reverse order (analog to the order of prioritiy in $PATH and similar).\n\nExample:\n\nconfig = LegendDataConfig(\"/path/to/config.json\")\nsetup = config.setups.l200\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\nSee also SetupConfig.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LegendReport","page":"LegendDataManagement","title":"LegendDataManagement.LegendReport","text":"struct LegendReport\n\nRepresents a LEGEND report.\n\nDon't instantiate directly, use lreport()\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LegendTierData","page":"LegendDataManagement","title":"LegendDataManagement.LegendTierData","text":"struct LegendDataManagement.LegendTierData\n\nConstructors:\n\n(data::LegendData).tier\n\nLegendDataManagement.LegendTierData(data::LegendData)\n\nThe path to data directories and files can be accessed via getindex on tier_data::LegendTierData:\n\ntier_data[]\ntier_data[tier::DataTierLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike, ch::ChannelIdLike]\n\ntier_data[tier::DataTierLike, filekey::FileKeyLike]\ntier_data[tier::DataTierLike, filekey::FileKeyLike, ch::ChannelIdLike]\n\nExamples:\n\n```julia l200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\") isfile(l200.tier[:raw, filekey])\n\nisdir(l200.tier[:raw, :cal]) isdir(l200.tier[:raw, :cal, \"p02\"]) isdir(l200.tier[:raw, :cal, \"p02\", \"r006\"]) isdir(l200.tier[DataTier(:raw), DataCategory(:cal), DataPeriod(2), DataRun(6)])\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.NoSuchPropsDBEntry","page":"LegendDataManagement","title":"LegendDataManagement.NoSuchPropsDBEntry","text":"struct LegendDataManagement.NoSuchPropsDBEntry\n\nIndicates that a given property (path) of a LegendDataManagementPropsDB[@ref] does not exist.\n\nSupports PropDicts.writeprops(missing_props::NoSuchPropsDBEntry, props::PropDicts.PropDict) to create the missing directories and file for the property path.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.PeriodSelLike","page":"LegendDataManagement","title":"LegendDataManagement.PeriodSelLike","text":"struct PeriodSelLike = Tuple{<:DataPeriodLike, <:DataCategoryLike}\n\nRepresents a LEGEND period selection for a specific category.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ProcessStatus","page":"LegendDataManagement","title":"LegendDataManagement.ProcessStatus","text":"@enum ProcessStatus\n\nMay be succeeded, pending, or failed.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.PropsDB","page":"LegendDataManagement","title":"LegendDataManagement.PropsDB","text":"struct LegendDataManagement.PropsDB\n\nA PropsDB instance, e.g. myprops, presents an on-disk directory containing JSON files or sub-directories (that contains JSON files in leaf directories) as a dictionary of properties.\n\nPropsDB supports Base.keys and Base.getindex as well as Base.propertynames and Base.getproperty to access it's contents. getindex and getproperty will return either another PropsDB or a PropDicts.PropDict, depending on whether the accessed property is stored as a sub-directory or a JSON file. We recommend to use getproperty where the properties/keys of the PropDict are more or less standardized and where they may be arbitrary (see examples below).\n\nThe contents of PropsDB may be time- and category-dependent, determined by the presence of a \"validity.json\" file. In this case, use myprops(sel::LegendDataManagement.ValiditySelection) or myprops(filekey::FileKey) to select the desired time and category. The selection can be made at some point during traversal of properties or at the leaf PropsDB (see the examples below).\n\nExamples:\n\nl200 = LegendData(:l200)\n\npropertynames(l200.metadata.hardware)\nl200.metadata.hardware.detectors.germanium\n\nkeys(l200.metadata.hardware.detectors.germanium.diodes)\nl200.metadata.hardware.detectors.germanium.diodes[:V99000A]\n\ndiodes = l200.metadata.hardware.detectors.germanium.diodes\ndiodes[keys(diodes)]\n\nsel = ValiditySelection(\"20221226T194007Z\", :cal)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T194007Z\")\ndata.metadata.hardware(sel).configuration.channelmaps\ndata.metadata.hardware.configuration.channelmaps(filekey)\n\nUse code should not instantiate PropsDB directly, use  LegendDataManagement.AnyProps(path::AbstractString) instead, which may return a PropsDB or a PropDicts.PropDict depending on what on-disk content path points to. \n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.RunCategorySelLike","page":"LegendDataManagement","title":"LegendDataManagement.RunCategorySelLike","text":"struct RunCategorySelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection for a specific category.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.RunSelLike","page":"LegendDataManagement","title":"LegendDataManagement.RunSelLike","text":"struct RunSelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.SetupConfig","page":"LegendDataManagement","title":"LegendDataManagement.SetupConfig","text":"struct SetupConfig\n\nData configuration for an experimental setup.\n\nSupports\n\ndata_path(setup, path_components)\n\nExamples:\n\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.Timestamp","page":"LegendDataManagement","title":"LegendDataManagement.Timestamp","text":"struct Timestamp <: DataSelector\n\nRepresents a LEGEND timestamp.\n\nExample:\n\njulia timestamp = Timestamp(\"20221226T200846Z\") timestamp.unixtime == 1672085326 string(timestamp) == \"20221226T200846Z\"`\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ValiditySelection","page":"LegendDataManagement","title":"LegendDataManagement.ValiditySelection","text":"struct LegendDataManagement.ValiditySelection\n\nRepresenty validiy selection for a LegendDataManagement.PropsDB[@ref].\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.AnyProps","page":"LegendDataManagement","title":"LegendDataManagement.AnyProps","text":"LegendDataManagement.AnyProps = Union{LegendDataManagement.PropsDB,PropDicts.PropDict}\n\nProperties stored either in a directory managed via [LegendDataManagement.PropsDB][@ref] or loaded from one or several files into a PropDicts.PropDict.\n\nConstructors:\n\nLegendDataManagement.AnyProps(base_path::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.AnyValiditySelection","page":"LegendDataManagement","title":"LegendDataManagement.AnyValiditySelection","text":"const AnyValiditySelection = Union{ValiditySelection,FileKey}\n\nAnything that can be used in time/category-based data selection.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ChannelIdLike","page":"LegendDataManagement","title":"LegendDataManagement.ChannelIdLike","text":"ChannelIdLike = Union{ChannelId, Integer, AbstractString}\n\nAnything that can represent a data channel, like ChannelId(1083204) or \"ch1083204\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataCategoryLike","page":"LegendDataManagement","title":"LegendDataManagement.DataCategoryLike","text":"DataCategoryLike = Union{DataCategory, Symbol, AbstractString}\n\nAnything that can represent a data category, like DataCategory(:cal), :cal or \"cal\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataPartitionLike","page":"LegendDataManagement","title":"LegendDataManagement.DataPartitionLike","text":"DataPartitionLike = Union{DataPartition, Symbol, AbstractString}\n\nAnything that can represent a data partition, like DataPartition(2) or \"partition02\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataPeriodLike","page":"LegendDataManagement","title":"LegendDataManagement.DataPeriodLike","text":"DataPeriodLike = Union{DataPeriod, Symbol, AbstractString}\n\nAnything that can represent a data period, like DataPeriod(2) or \"p02\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataRunLike","page":"LegendDataManagement","title":"LegendDataManagement.DataRunLike","text":"DataRunLike = Union{DataRun, Symbol, AbstractString}\n\nAnything that can represent a data run, like DataRun(6) or \"r006\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataTierLike","page":"LegendDataManagement","title":"LegendDataManagement.DataTierLike","text":"DataTierLike = Union{DataTier, Symbol, AbstractString}\n\nAnything that can represent a data tier, like DataTier(:raw), :raw or \"raw\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DetectorIdLike","page":"LegendDataManagement","title":"LegendDataManagement.DetectorIdLike","text":"DetectorIdLike = Union{DetectorId, Symbol, AbstractString}\n\nAnything that can represent a detector id.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ExpSetupLike","page":"LegendDataManagement","title":"LegendDataManagement.ExpSetupLike","text":"ExpSetupLike = Union{ExpSetup, Symbol, AbstractString}\n\nAnything that can represent a setup label, like ExpSetup(:l200), :l200 or \"l200\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.FileKeyLike","page":"LegendDataManagement","title":"LegendDataManagement.FileKeyLike","text":"FileKeyLike = Union{FileKey, AbstractString}\n\nAnything that can represent a file key, like FileKey(\"l200-p02-r006-cal-20221226T200846Z\") or \"l200-p02-r006-cal-20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LJlExprLike","page":"LegendDataManagement","title":"LegendDataManagement.LJlExprLike","text":"const LJlExprLike = Union{Expr, Symbol, Integer, AbstractFloat}\n\nAnything that can represent a parsed LEGEND Julia expression.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.TimestampLike","page":"LegendDataManagement","title":"LegendDataManagement.TimestampLike","text":"TimestampLike = Union{Timestamp, AbstractString, Integer}\n\nAnything that can represent a timestamp, like Timestamp(\"20221226T200846Z\") or \"20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.analysis_runs-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.analysis_runs","text":"analysis_runs(data::LegendData)\n\nReturn cross-period analysis runs.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.atomic_fcreate-Tuple{Any, Vararg{AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.atomic_fcreate","text":"function atomic_fcreate(\n    body, filenames::AbstractString...;\n    create_dirs::Bool = true, overwrite::Bool = true, delete_on_error::Bool=true\n)\n\nCreates filenames in an atomic fashion.\n\nCreates temporary files in the same directories as filenames, then calls body(temporary_filenames...). If body returns successfully, the files temporary_filenames are renamed to filenames. If body throws an exception, the temporary files are either deleted (if delete_on_error is true) or left in place (e.g. for debugging purposes).\n\nIf create_dirs is true, directories are created if necessary.\n\nIf all of files already exist and overwrite is false, takes no action (or, if the file is created by other code running in parallel, while body is running, does not overwrite it).\n\nThrows an error if only some of the files exist and overwrite is false.\n\nReturns nothing.\n\nExample:\n\natomic_fcreate(\"foo.txt\", \"bar.txt\") do foo, bar\n    write(foo, \"Hello\")\n    write(bar, \"World\")\nend\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.bad_filekeys-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.bad_filekeys","text":"bad_filekeys(data::LegendData)\n\nGet the list of filekeys to ignore for data.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.channelinfo-Tuple{LegendData, AnyValiditySelection}","page":"LegendDataManagement","title":"LegendDataManagement.channelinfo","text":"channelinfo(data::LegendData, sel::AnyValiditySelection; system::Symbol = :all, only_processable::Bool = false)\nchannelinfo(data::LegendData, sel::RunCategorySelLike; system::Symbol = :all, only_processable::Bool = false)\n\nGet all channel information for the given LegendData and ValiditySelection.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.channelinfo-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, Union{Int64, ChannelId, DetectorIdLike}}","page":"LegendDataManagement","title":"LegendDataManagement.channelinfo","text":"channelinfo(data::LegendData, sel::AnyValiditySelection, channel::Union{ChannelIdLike, DetectorIdLike})\nchannelinfo(data::LegendData, sel::AnyValiditySelection, detector::DetectorIdLike)\n\nGet channel information validitiy selection and DetectorId resp. ChannelId.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.data_path","page":"LegendDataManagement","title":"LegendDataManagement.data_path","text":"data_path(setup::SetupConfig, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\nConverts between \"/\" and \"\\\" inside of path_components if necessary (for Windows compatibility).\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.data_path-Tuple{LegendDataManagement.AbstractSetupData, Vararg{AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.data_path","text":"data_path(setup::AbstractSetupData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.data_path-Tuple{LegendDataManagement.LegendTierData, Vararg{AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.data_path","text":"data_path(tier_data::LegendTierData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components relative to tier_data.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.data_path-Tuple{LegendDataManagement.PropsDB}","page":"LegendDataManagement","title":"LegendDataManagement.data_path","text":"data_path(pd::LegendDataManagement.PropsDB)\n\nReturn the path to the data directory that contains pd.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.dataprod_config-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.dataprod_config","text":"dataprod_config(data::LegendData)\n\nGet the Julia data production configuration for data.\n\nUse dataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\ndataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\ndataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.dataprod_parameters-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.dataprod_parameters","text":"dataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.dataprod_pars_aoe_window-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.dataprod_pars_aoe_window","text":"LegendDataManagement.dataprod_pars_aoe_window(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the A/E cut window for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_cal_propfunc","text":"get_ged_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the HPGe calibration function for the given data, validity selection and detector.\n\nNote: Caches configuration/calibration data internally, use a fresh data object if on-disk configuration/calibration data may have changed.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_evt_chdata_propfunc","text":"get_ged_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_qc_cuts_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_qc_cuts_propfunc","text":"get_ged_qc_cuts_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector QC cut definitions for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_qc_is_baseline_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_qc_is_baseline_propfunc","text":"get_ged_qc_is_baseline_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet a PropertyFunction that returns true for events that fullfill the is_baseline definition.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_qc_is_physical_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_qc_is_physical_propfunc","text":"get_ged_qc_is_physical_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet a PropertyFunction that returns true for events that fullfill the is_physical definition.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_qc_is_trig_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_qc_is_trig_propfunc","text":"get_ged_qc_istrig_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector trigger condition for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_partition_combined_periods-Tuple{LegendData, DataPeriodLike}","page":"LegendDataManagement","title":"LegendDataManagement.get_partition_combined_periods","text":"get_partition_combined_periods(data::LegendData, period::DataPeriodLike; chs::Vector{ChannelIdLike}=ChannelIdLike[])\n\nGet a list periods which are combined in any partition for the given period and list of channels.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_pulser_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_pulser_cal_propfunc","text":"get_pulser_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the pulser calibration function for the given data, validity selection and the pulser channel referred to by detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_setup_config","page":"LegendDataManagement","title":"LegendDataManagement.get_setup_config","text":"LegendDataManagement.get_setup_config(data::AbstractSetupData)::SetupConfig\n\nMust be specialized for each subtype of AbstractSetupData.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_spm_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_spm_cal_propfunc","text":"get_spm_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_uncertainties","page":"LegendDataManagement","title":"LegendDataManagement.get_uncertainties","text":"get_uncertainties(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_uncertainties(x::Unitful.Quantity{<:Real})\nget_uncertainties(pd::PropDict)\nget_uncertainties(A::AbstractArray)\n\nGet the uncertainty of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_values","page":"LegendDataManagement","title":"LegendDataManagement.get_values","text":"get_values(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_values(x::Unitful.Quantity{<:Real})\nget_values(pd::PropDict)\nget_values(A::AbstractArray)\n\nGet the value of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.is_analysis_cal_run-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}}}","page":"LegendDataManagement","title":"LegendDataManagement.is_analysis_cal_run","text":"is_analysis_cal_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike))\n\nReturn true if run is an analysis run for data in period. \n\nATTENTION: This is only valid for cal runs.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.is_analysis_phy_run-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}}}","page":"LegendDataManagement","title":"LegendDataManagement.is_analysis_phy_run","text":"is_analysis_phy_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike))\n\nReturn true if run is an analysis run for data in period. \n\nATTENTION: This is only valid for phy runs.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.is_analysis_run-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"LegendDataManagement","title":"LegendDataManagement.is_analysis_run","text":"is_analysis_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike, cat::DataCategoryLike))\n\nReturn true if run is an cat analysis run for data in period.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.is_lrun-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"LegendDataManagement","title":"LegendDataManagement.is_lrun","text":"is_lrun(data::LegendData, runsel::RunSelLike)\n\nReturn true if runsel is a valid run for data and therefore appears in the metadata.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.livetime-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"LegendDataManagement","title":"LegendDataManagement.livetime","text":"livetime(data::LegendData, runsel::RunSelLike)\n\nGet the livetime for data in physics data taking of run in period.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ljl_propfunc","page":"LegendDataManagement","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr::LJlExprLike)\nljl_propfunc(expr_string::AbstractString)\n\nCompiles a PropertyFunctions.PropertyFunction from a LEGEND Julia expression.\n\nSee also parse_lpyexpr.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ljl_propfunc-Tuple{AbstractDict{Symbol, <:Union{AbstractFloat, Expr, Integer, Symbol}}}","page":"LegendDataManagement","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr_map::AbstractDict{Symbol,<:LJlExprLike})\nljl_propfunc(expr_map::AbstractDict{Symbol,<:AbstractString})\nljl_propfunc(expr_map::PropDict)\n\nCompiles a map between output field-names and LEGEND Julia expressions to a single PropertyFunctions.PropertyFunction.\n\nThe generated function will return NamedTuples with the same property names as the keys of expr_map.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.lpy_propfunc-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.lpy_propfunc","text":"lpy_propfunc(expr_string::AbstractString)::PropertyFunctions.PropertyFunction\n\nGenerate a PropertyFunctions.PropertyFunction from a LEGEND Python expression.\n\nSee also parse_lpyexpr and ljl_propfunc.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.lreport","page":"LegendDataManagement","title":"LegendDataManagement.lreport","text":"lreport()\nlreport(contents...)\n\nGenerate a LEGEND report, e.g. a data processing report.\n\nUse lreport!(rpt, contents...) to add more content to a report.\n\nExample:\n\nusing LegendDataManagement, StructArrays, IntervalSets, Plots\n\ntbl = StructArray(\n    col1 = rand(5), col2 = ClosedInterval.(rand(5), rand(5).+1),\n    col3 = [rand(3) for i in 1:5], col4 = ProcessStatus.(rand(-1:1, 5)),\n    col5 = [:a, :b, :c, :d, :e], col6 = [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    col7 = [:(a[1]), :(a[2]), :(a[3]), :(a[4]), :(a[5])]\n)\n\nrpt = lreport(\n    \"# New report\",\n    \"Table 1:\", tbl\n)\nlreport!(rpt, \"Figure 1:\", stephist(randn(10^3)))\nlreport!(rpt, \"Figure 2:\", histogram2d(randn(10^4), randn(10^4), format = :png))\n\nshow(stdout, MIME\"text/plain\"(), rpt)\nshow(stdout, MIME\"text/html\"(), rpt)\nshow(stdout, MIME\"text/markdown\"(), rpt)\n\nwritelreport(\"report.txt\", rpt)\nwritelreport(\"report.html\", rpt)\nwritelreport(\"report.md\", rpt)\n\nSee LegendDataManagement.lreport_for_show! for how to specialize the behavior of show for specific report content types.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.lreport!","page":"LegendDataManagement","title":"LegendDataManagement.lreport!","text":"lreport!(rpt::LegendReport, contents...)\n\nAdd more content to report rpt. See lreport for an example.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.lreport_for_show!","page":"LegendDataManagement","title":"LegendDataManagement.lreport_for_show!","text":"LegendDataManagement.lreport_for_show!(rpt::LegendReport, mime::MIME, content)\n\nAdd the contents of content to rpt in a way that is optimized for being displayed (e.g. via show) with the given mime type.\n\nshow(output, mime, rpt) first transforms rpt by converting all contents of rpt using lreport_for_show!(rpt::LegendReport, mime, content).\n\nDefaults to lreport!(rpt, content), except for tables (Tables.istable(content) == true), which are converted to Markdown tables by default for uniform appearance.\n\nlreport_for_show! is not inteded to be called by users, but to be specialized for specific types of content content. Content types not already supported will primarily require specialization of\n\nlreport_for_show!(rpt::LegendReport, ::MIME\"text/markdown\", content::SomeType)\n\nIn some cases it may be desireable to specialize lreport_for_show! for MIME types like MIME\"text/html\" and MIME\"text/plain\" as well.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.map_datafiles-Tuple{Any, Any, LegendData, DataCategoryLike, AbstractVector{<:FileKey}}","page":"LegendDataManagement","title":"LegendDataManagement.map_datafiles","text":"map_datafiles(\n    f_process, f_open, data::LegendData,\n    category::DataCategoryLike, filekeys::AbstractVector{<:FileKey}\n)\n\nProcesses all filekeys in data for category.\n\nOpens the files using f_open and processes them using f_process.\n\nReturns a @NamedTuple{result::Dict{Filekey}, failed::Dict{Filekey}, success::Bool}:\n\nvalues(result) contains the results f_process(f_open(filename)) for  all filenames referred to by category and filekeys.\nvalues(result) contains the error where processing failed.\nsuccess equals isempty(failed)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.parse_ljlexpr-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.parse_ljlexpr","text":"parse_ljlexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an LEGEND Julia expression and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.parse_lpyexpr-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.parse_lpyexpr","text":"parse_lpyexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an expression compatible with the LEGEND Python software and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.partitioninfo-Tuple{LegendData, Union{Int64, ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.partitioninfo","text":"partitioninfo(data::LegendData, s::ChannelIdLike)\n\nReturn cross-period data partitions.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.process_ljlexpr","page":"LegendDataManagement","title":"LegendDataManagement.process_ljlexpr","text":"process_ljlexpr(expr::LJlExprLike, f_varsubst = identity)::LJlExprLike\n\nVerify that expr is a valid LEGEND Julia expression and return it, with modifications if necessary.\n\nOptionally substitute variables in expr using f_varsubst.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.pydataprod_config-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.pydataprod_config","text":"pydataprod_config(data::LegendData)\n\nGet the Python data production configuration for data.\n\nUse pydataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\npydataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\npydataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.pydataprod_parameters-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.pydataprod_parameters","text":"pydataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.read_filekeys-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.read_filekeys","text":"read_filekeys(filename::AbstractString)::AbstractVector{FileKey}\n\nReads a list of FileKey from a text file, one file key per line.\n\nIgnores empty lines. # may be used to start a comment in the file.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.readlprops","page":"LegendDataManagement","title":"LegendDataManagement.readlprops","text":"readlprops(filename::AbstractString)\nreadprops(filenames::Vector{<:AbstractString})\n\nRead a PropDict from a file and parse it to Unitful.Quantity and Measurements.Measurement objects.\n\nReturns\n\npd::PropDict with all :val fields converted to Unitful.Quantity objects and all :val fields converted to Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.runinfo-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.runinfo","text":"runinfo(data::LegendData)::Table\nruninfo(data::LegendData, runsel::RunSelLike)::NamedTuple\nruninfo(data::LegendData, filekey::FileKey)::NamedTuple\n\nGet the run information for data.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.search_disk","page":"LegendDataManagement","title":"LegendDataManagement.search_disk","text":"search_disk(::Type{<:DataSelector}, path::AbstractString)\n\nSearch on-disk data for data categories, periods, runs, and filekeys.\n\nExamples:\n\nl200 = LegendData(:l200)\n\nsearch_disk(DataCategory, l200.tier[:raw])\nsearch_disk(DataPeriod, l200.tier[:raw, :cal])\nsearch_disk(DataRun, l200.tier[:raw, :cal, \"p02\"])\nsearch_disk(FileKey, l200.tier[DataTier(:raw), :cal, DataPeriod(2), \"r006\"])\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.start_filekey-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"LegendDataManagement","title":"LegendDataManagement.start_filekey","text":"start_filekey(data::LegendData, runsel::RunCategorySelLike)\n\nGet the starting filekey for data in period, run, category.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.tmp_filename-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.tmp_filename","text":"LegendDataManagement.tmp_filename(fname::AbstractString)\n\nReturns a temporary filename, based on fname, in the same directory.\n\nDoes not create the temporary file.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.write_filekeys-Tuple{AbstractString, AbstractVector{<:FileKey}}","page":"LegendDataManagement","title":"LegendDataManagement.write_filekeys","text":"write_filekeys(filename::AbstractString, filekeys::AbstractVector{<:FileKey})\n\nWrites a list of FileKey to a text file, one file key per line.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.writelprops","page":"LegendDataManagement","title":"LegendDataManagement.writelprops","text":"writelprops(f::IO, p::PropDict; write_units::Bool=true, write_errors::Bool=true, mutliline::Bool=true, indent::Int=4)\nwritelprops(filename::AbstractString, p::PropDict; multiline::Bool=true, indent::Int=4)\nwritelprops(db::PropsDB, key::Union{Symbol, DataSelector}, p::PropDict; kwargs...)\n\nWrite a PropDict to a file and strip it to :val and :unit fields and :val and :err fields.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.writelreport","page":"LegendDataManagement","title":"LegendDataManagement.writelreport","text":"writelreport(filename::AbstractString, rpt::LegendReport)\nwritelreport(filename::AbstractString, mime::MIME, rpt::LegendReport)\n\nWrite lreport rpt to file filename.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.channel2detector-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, Union{Int64, ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.channel2detector","text":"channel2detector(data::LegendData, sel::Union{AnyValiditySelection, RunCategorySelLike}, channel::ChannelIdLike)\n\nGet the DetectorId for a given ChannelId input: \n\ndata, e.g. LegendData(:l200)`\nrunsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\nchannel: ChannelId e.g. ChannelId(1080005)`\n\noutput:\n\nDetectorId of corresponding channel\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.create_logtbl-Tuple{Any}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.create_logtbl","text":"create_logtbl(result)\n\nCreate a log table for a given result which can be added in a report.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.create_metadatatbl","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.create_metadatatbl","text":"create_metadatatbl(filekey::FileKey)\ncreate_metadatatbl(filekey::FileKey, part::DataPartitionLike)\n\nCreate a metadata table for a given filekey which can be added in a report.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.create_pars-Tuple{PropDicts.PropDict, Any}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.create_pars","text":"create_pars(pd::PropDict, result::Dict{ChannelInfo, ChannelResult}) -> PropDict\n\nCreate a PropDict from a result of the parallel processing\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.create_validity-Tuple{Any}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.create_validity","text":"create_validity(result) -> StructArray\n\nCreate a StructArray from a result of the parallel processing\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.data_starttime-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.data_starttime","text":"data_starttime(data::LegendData, runsel::Union{AnyValiditySelection, RunCategorySelLike})\n\nExtract startime as DateTime from file for a given run selection     Input:     * data: LegendData, e.g. LegendData(:l200)     * runsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.detector2channel-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, DetectorIdLike}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.detector2channel","text":"detector2channel(data::LegendData, sel::Union{AnyValiditySelection, RunCategorySelLike}, detector::DetectorIdLike)\n\nGet the ChannelId for a given detectorId  input: \n\ndata, e.g. LegendData(:l200)`\nrunsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\ndetector: DetectorID e.g. DetectorId(:P00573A)OR ChannelID e.g.ChannelId(1080005)``\n\noutput:\n\nChannelId of corresponding detector\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.detector_type-Tuple{LegendData, DetectorIdLike}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.detector_type","text":"get_det_type(data::LegendData, det::DetectorIdLike)\n\nLooks up the detector type for a given DetectorID.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_hitchfilename-Tuple{LegendData, ExpSetupLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_hitchfilename","text":"get_hitchfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike)\nget_hitchfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike)\n\nGet the filename for the hitch data for a given channel.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_mltrainfilename","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_mltrainfilename","text":"get_mltrainfilename(data::LegendData, period::DataPeriodLike, category::DataCategoryLike)\nget_mltrainfilename(data::LegendData, filekey::FileKey)\n\nGet the filename for the machine learning training data.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_partitionfilekeys-Tuple{LegendData, DataPartitionLike, DataTierLike, DataCategoryLike}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_partitionfilekeys","text":"get_partitionfilekeys(data::LegendData, part::DataPartitionLike, tier::DataTierLike, category::DataCategoryLike; only_good::Bool=true)\n\nGet filekeys for a given partition.\n\nArguments\n\ndata::LegendData: data object\npart::DataPartitionLike: partition to be searched in\ntier::DataTierLike: tier\ncategory::DataCategoryLike: category\nonly_good::Bool=true: only get good filekeys\n\nReturn\n\nVector{FileKey}: filekeys\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_partitionvalidity","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_partitionvalidity","text":"get_partitionvalidity(data::LegendData, ch::ChannelIdLike, part::DataPartitionLike, cat::DataCategoryLike=:cal) -> Vector{@NamedTuple{period::DataPeriod, run::DataRun, validity::String}}\n\nGet partition validity for a given channel and partition.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_peaksfilename-Tuple{LegendData, ExpSetupLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_peaksfilename","text":"get_peaksfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike)\nget_peaksfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike)\n\nGet the filename for the peaks data for a given channel.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_plottitle","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_plottitle","text":"get_plottitle(setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, det::DetectorIdLike, process::String; additiional_type::String=\"\")\nget_plottitle(filekey::FileKey, det::DetectorIdLike, process::String; kwargs...)\nget_plottitle(setup::ExpSetupLike, partition::DataPartitionLike, category::DataCategoryLike, det::DetectorIdLike, process::String; additiional_type::String=\"\")\n\nGet the title for a plot.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_pltfilename","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_pltfilename","text":"get_pltfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol)\nget_pltfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike, process::Symbol)\nget_pltfilename(data::LegendData, partition::DataPartitionLike, setup::ExpSetupLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol)\n\nGet the filename for the plot file for a given setup, period, run, category, channel and process.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_pltfolder","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_pltfolder","text":"get_pltfolder(data::LegendData, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, process::Symbol)\nget_pltfolder(data::LegendData, filekey::FileKey, process::Symbol)\nget_pltfolder(data::LegendData, partition::DataPartitionLike, category::DataCategoryLike, process::Symbol, ch::ChannelIdOrDetectorIDLike)\n\nGet the folder for the plot files for a given period, run, category and process.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_preportfilename","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_preportfilename","text":"get_preportfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, category::DataCategoryLike, process::Symbol)\n\nGet the filename for the log file for a given setup, period, category and process.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_preportfolder","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_preportfolder","text":"get_preportfolder(data::LegendData, period::DataPeriodLike, category::DataCategoryLike)\n\nGet the preport folder for the log files for a given period and category.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_rreportfilename","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_rreportfilename","text":"get_rreportfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, process::Symbol)\nget_rreportfilename(data::LegendData, filekey::FileKey, process::Symbol)\n\nGet the filename for the log file for a given setup, period, run, category and process.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_rreportfolder","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_rreportfolder","text":"get_rreportfolder(data::LegendData, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike)\n\nGet the rreport folder for the log files for a given period, run and category.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_totalTimer-Tuple{Vector}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_totalTimer","text":"get_totalTimer(result::Vector)\n\nGet the total timer from a result vector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.load_partition_ch-Tuple{Function, Function, LegendData, TypedTables.Table, DataTierLike, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.load_partition_ch","text":"load_partition_ch(open_func::Function, flatten_func::Function, data::LegendData, partinfo::StructVector, tier::DataTierLike, cat::DataCategoryLike, ch::ChannelIdLike; data_keys::Tuple=(), n_evts::Int=-1, select_random::Bool=false)\nload_partition_ch(open_func::Function, flatten_func::Function, data::LegendData, part::DataPartition, tier::DataTierLike, cat::DataCategoryLike, ch::ChannelIdLike; kwargs...)\n\nLoad data for a channel from a partition. \n\nArguments\n\nopen_func::Function: function to open a file\nflatten_func::Function: function to flatten data\ndata::LegendData: data object\npartinfo::StructVector: partition info\ntier::DataTierLike: tier\ncat::DataCategoryLike: category\nch::ChannelIdLike: channel\ndata_keys::Tuple=(): data keys, empty tuple selects all keys\nn_evts::Int=-1: number of events, -1 selects all events\nselect_random::Bool=false: select events randomly\n\nReturn\n\nTable: data table with flattened events\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.load_raw_evt","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.load_raw_evt","text":"load_raw_evt(open_func::Function, data::LegendData, ch::ChannelIdLike, data_hit::Table, sel_evt::Int)\nload_raw_evt(open_func::Function, data::LegendData, ch::ChannelIdLike, data_hit::Table, sel_evt::UnitRange{Int})\n\nLoad data for a channel from a hitch file for a given selected event index or index range.\n\nArguments\n\nopen_func::Function: function to open a file\ndata::LegendData: data object\nch::ChannelIdLike: channel\ndata_hit::Table: hitch data\nsel_evt::Int/UnitRange{Int}: selected event index\n\nReturn\n\nTable: data table of raw events\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.load_run_ch","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.load_run_ch","text":"load_run_ch(open_func::Function, flatten_func::Function, data::LegendData, filekeys::Vector{FileKey}, tier::DataTierLike, ch::ChannelIdLike; check_filekeys::Bool=true)\n\nLoad data for a channel from a list of filekeys in a given tier.\n\nArguments\n\nopen_func::Function: function to open a file\nflatten_func::Function: function to flatten data\ndata::LegendData: data object\nfilekeys::Vector{FileKey}: list of filekeys\ntier::DataTierLike: tier to load data from\nch::ChannelIdLike: channel to load data for\ncheck_filekeys::Bool=true: check if filekeys are valid\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.savelfig","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.savelfig","text":"savelfig(save_func::Function, p, data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol; kwargs...)\nsavelfig(save_func::Function, p, data::LegendData, filekey::FileKey, ch::ChannelIdLike, process::Symbol; kwargs...)\nsavelfig(save_func::Function, p, data::LegendData, partition::DataPartitionLike, setup::ExpSetupLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol; kwargs...)\n\nSave a lplot.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.writevalidity","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.writevalidity","text":"writevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey; apply_to::Symbol=:all)\nwritevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey, part::DataPartitionLike; apply_to::Symbol=:all)\n\nWrite validity for a given filekey.\n\n\n\n\n\n","category":"function"},{"location":"#Juleana.jl","page":"Home","title":"Juleana.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Juleana.jl provides a Julia implementation of LEGEND global event analysis tools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Juleana is a meta package that represents the LEGEND Julia software stack. This stack comprises (mainly) the following Julia packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"LegendDataManagement\nLegendDataTypes\nLegendHDF5IO\nLegendTextIO\nLegendDSP\nLegendSpecFits\nLegendEventAnalysis\nLegendTestData\nRadiationDetectorSignals\nRadiationDetectorDSP\nSolidStateDetectors\nBAT","category":"page"},{"location":"","page":"Home","title":"Home","text":"Juleana depends on, imports and exports all the packages listed above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(As a consequence, any breaking version change in one of these package has to result in a breaking version change of the Juleana package itself.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"So one can, for example, do (but see caveats below)","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Juleana\n\ndata = LegendDataManagement.LegendData(:l200)\n\nusing LegendHDF5IO\ninput = lh5open(...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"without (in this example) import LegendDataManagement and without adding LegendDataManagement and LegendHDF5IO to the dependencies (Project.toml) of the active project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"But: note that this approach is intended only for easy interactive exploration of the LEGEND Julia software stack and for convenient use in scripts and notebooks! Also note that due to it's heavy dependencies, using Juleana will result in longer load times than using only the individual packages that you need.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This approach must not be used in packages. Packages must not depend on Juleana at all, instead packages must only and directly depend on the packages they use! using Juleana and import Juleana have no place in package code and Juleana should never be added to package Project.toml files.","category":"page"},{"location":"assets/README/#Juleana-logo","page":"Juleana logo","title":"Juleana logo","text":"","category":"section"},{"location":"assets/README/","page":"Juleana logo","title":"Juleana logo","text":"The Juleana logo is available here in various formats.","category":"page"},{"location":"assets/README/","page":"Juleana logo","title":"Juleana logo","text":"The master (editable) logo file is \"juleana-logo-inkscape.svg\", it requires the Julia font \"TamilMN-Bold.ttf\" (not included here, but available at https://github.com/JuliaLang/julia-logo-graphics).","category":"page"}]
}
